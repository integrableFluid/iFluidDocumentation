{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the iFluid documentation iFluid is an open-source Matlab framework for simulating the dynamics of integrable models using the theory of generalized hydrodynamics. Getting started Simply pull the iFluid code from the Github repository","title":"Home"},{"location":"#welcome-to-the-ifluid-documentation","text":"iFluid is an open-source Matlab framework for simulating the dynamics of integrable models using the theory of generalized hydrodynamics.","title":"Welcome to the iFluid documentation"},{"location":"#getting-started","text":"Simply pull the iFluid code from the Github repository","title":"Getting started"},{"location":"iFluidCore/","text":"iFluidCore This class implements the general TBA equations. Following the hydrodynamical principle, the system is always in a quasi-stationary state, whereby all the methods of the class can be applied at any time for any given filling function. Note, the iFluidCore class is abstract and must be extended by classes encoding an actual integrable model. Click here to see how to implement your own model. Constructor obj = iFluidCore(x_grid, rapid_grid, rapid_w, couplings, Ntypes, Options) Construct an iFluidCore object containing all the information and methods of a TBA of a given model. Inputs: x_grid : Vector of M gridpoints in position space. rapid_grid : Vector of N gridpoints in rapidity space. rapid_w : Vector of N rapidity quadrature weights. couplings : Cell array of couplings and their time and space derivatives. Ntypes : Number of quasiparticle types in the TBA of the model. Options : Struct of settings. Returns: obj : iFluidCore object. Abstract (model specific) methods ebare = getBareEnergy(obj, t, x, rapid, type) Calculate the one-particle energy. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: ebare : One-particle energy. pbare = getBareMomentum(obj, t, x, rapid, type) Calculate the one-particle momentum. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: pbare : One-particle momentum. de = calcEnergyRapidDeriv(obj, t, x, rapid, type) Calculate the derivative of the one-particle energy w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: de : Derivative of one-particle energy. dp = calcMomentumRapidDeriv(obj, t, x, rapid, type) Calculate the derivative of the one-particle momentum w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: dp : Derivative of one-particle momentum. dT = calcScatteringRapidDeriv(obj, t, x, rapid1, rapid2, type1, type2) Calculate the derivative of the two-body scattering phase w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid1 : Scalar or vector indicating the (main) rapidity. rapid2 : Scalar or vector indicating the (convilution) rapidity. type1 : Scalar or vector indicating the (main) type index of the quasiparticles. type2 : Scalar or vector indicating the (convolution) type index of the quasiparticles. Returns: dT : Derivative of the two-body scattering phase. Must be an iFluidTensor . de = calcEnergyCouplingDeriv(obj, coupIdx, t, x, rapid, type) Calculate the derivative of the one-particle energy w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: de : Derivative of one-particle energy. dp = calcMomentumCouplingDeriv(obj, coupIdx, t, x, rapid, type) Calculate the derivative of the one-particle momentum w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: dp : Derivative of one-particle momentum. dT = calcScatteringCouplingDeriv(obj, coupIdx, t, x, rapid1, rapid2, type1, type2) Calculate the derivative of the two-body scattering phase w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid1 : Scalar or vector indicating the (main) rapidity. rapid2 : Scalar or vector indicating the (convilution) rapidity. type1 : Scalar or vector indicating the (main) type index of the quasiparticles. type2 : Scalar or vector indicating the (convolution) type index of the quasiparticles. Returns: dT : Derivative of the two-body scattering phase. Must be an iFluidTensor . Accessor methods setCouplings(obj, couplings) Set the couplings of the model. Inputs: couplings : Cell array of couplings and their time and space derivatives. couplings = getCouplings(obj) Get the couplings of the model. Returns: couplings : Cell array of couplings and their time and space derivatives. [x_grid, rapid_grid, type_grid, rapid_w] = getGrids(obj) Get all grids of the system. Returns: x_grid : Vector of M gridpoints in position space. rapid_grid : Vector of N gridpoints in rapidity space. rapid_w : Vector of N rapidity quadrature weights. type_grid : Vector from 1 to Ntypes . TBA methods Q_dr = applyDressing(obj, Q, theta, t) Dress the quantity Q , threby taking into account the collective iteractions of the quasiparticles. Inputs: Q : Quantity to be dressed. Must be an iFluidTensor . theta : Filling function at time t . Must be an iFluidTensor . t : Scalar indicating the time, corresponding to theta . Returns: Q_dr : Dressed quantity as iFluidTensor . h_i = getOneParticleEV(obj, charIdx, t, x, rapid) Returns the one-particle eigenvalue of the i'th conserved charge. By default the 0th charge is the number operator, the 1st charge is the momentum, and the 2nd charge is the Hamiltonian. Inputs: charIdx : Scalar indicating which charge is considered. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. Returns: h_i : Matrix containing the eigenvalues. [rho_t, rhoS_t] = transform2rho(obj, theta_t, t_array) Constructs the root density and the density of states from the filling function. Inputs: theta_t : Cell array of (or single) filling functions as iFluidTensor . t_array : Vector of times corresponding to the fillings in theta_t . Returns: rho_t : Cell array of (or single) root densities as iFluidTensor . rhoS_t : Cell array of (or single) density of states as iFluidTensor . [theta_t, rhoS_t] = transform2theta(obj, rho_t, t_array) Constructs the filling function and the density of states from the root density. Inputs: rho_t : Cell array of (or single) root densities as iFluidTensor . t_array : Vector of times corresponding to the root densities in rho_t . Returns: theta_t : Cell array of (or single) filling functions as iFluidTensor . rhoS_t : Cell array of (or single) density of states as iFluidTensor . [q, j] = calcCharges(obj, c_idx, theta_t, t_array) Calculate the expectation values of the i'th charge densities and associated currents. Inputs: c_idx : Scalar or vector of indices indicating which charges to consider. theta_t : Cell array of (or single) filling functions as iFluidTensor . t_array : Vector of times corresponding to the fillings in theta_t . Returns: q : Matrix of charge density expectation values for times in t_array . j : Matrix of charge current expectation values for times in t_array . [theta, e_eff] = calcThermalState(obj, T, TBA_couplings) Calculates a thermal state of the model specified by the couplings and temperature. Inputs: T : Temperature. Can be either a scalar (homogeneous) or an anonymous function of x (inhomogeneous). TBA_couplings : (Optional) Cell array of couplings. If none specified, the couplings of the iFluidCore object are used instead. Returns: theta : Filling function of thermal state as iFluidTensor . e_eff : Pseudo-energy of thermal state as iFluidTensor . [v_eff, a_eff] = calcEffectiveVelocities(obj, theta, t, x, rapid, type) Calculate the effective velocity and acceleration of the quasiparticles given the current state of the system. Inputs: theta : Filling function at time t . t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: v_eff : Effective velocity as iFluidTensor . a_eff : Effective acceleration as iFluidTensor . e_eff = calcEffectiveEnergy(obj, T, t, x, rapid) Calculate the pseudo-energy of the system. Inputs: T : Temperature. Can be either a scalar (homogeneous) or an anonymous function of x (inhomogeneous). t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. Returns: e_eff : Peuso-energy as iFluidTensor . Methods dependent on quasiparticle statisitcs f = getStatFactor(obj, theta) Returns the statistical factor based the statistics followed by the quasiparticles of the model. Inputs: theta : Filling function as iFluidTensor . Returns: f : Statistical factor as iFluidTensor . F = getFreeEnergy(obj, e_eff) Returns the free energy function of the model based on the quasiparticle statistics. Inputs: e_eff : Pseudo-energy of the state as iFluidTensor . Returns: F : Free energy function as iFluidTensor . theta = calcFillingFraction(obj, e_eff) Calculates the filling function of a thermal state based on the quasiparticle statistics. Inputs: e_eff : Pseudo-energy of the state as iFluidTensor . Returns: theta : Filling function as iFluidTensor . Options The iFluidCore class takes an Options struct as argument in its constructor. The Options struct can hold the following (case sensitive!) parameters, which are transferred to the iFluidCore object upon construction. The possible options are: homoEvol (default false ): Indicates if all couplings are homogeneous. If true, a_eff will not be calculated. tolerance (default 1e-6 ): Tolerance for iterative solution for pseudo-energy. maxcount (default 100 ): Max nnumber of iterations for finding pseudo-energy.","title":"iFluidCore"},{"location":"iFluidCore/#ifluidcore","text":"This class implements the general TBA equations. Following the hydrodynamical principle, the system is always in a quasi-stationary state, whereby all the methods of the class can be applied at any time for any given filling function. Note, the iFluidCore class is abstract and must be extended by classes encoding an actual integrable model. Click here to see how to implement your own model.","title":"iFluidCore"},{"location":"iFluidCore/#constructor","text":"","title":"Constructor"},{"location":"iFluidCore/#obj-ifluidcorex_grid-rapid_grid-rapid_w-couplings-ntypes-options","text":"Construct an iFluidCore object containing all the information and methods of a TBA of a given model. Inputs: x_grid : Vector of M gridpoints in position space. rapid_grid : Vector of N gridpoints in rapidity space. rapid_w : Vector of N rapidity quadrature weights. couplings : Cell array of couplings and their time and space derivatives. Ntypes : Number of quasiparticle types in the TBA of the model. Options : Struct of settings. Returns: obj : iFluidCore object.","title":"obj = iFluidCore(x_grid, rapid_grid, rapid_w, couplings, Ntypes, Options)"},{"location":"iFluidCore/#abstract-model-specific-methods","text":"","title":"Abstract (model specific) methods"},{"location":"iFluidCore/#ebare-getbareenergyobj-t-x-rapid-type","text":"Calculate the one-particle energy. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: ebare : One-particle energy.","title":"ebare = getBareEnergy(obj, t, x, rapid, type)"},{"location":"iFluidCore/#pbare-getbaremomentumobj-t-x-rapid-type","text":"Calculate the one-particle momentum. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: pbare : One-particle momentum.","title":"pbare = getBareMomentum(obj, t, x, rapid, type)"},{"location":"iFluidCore/#de-calcenergyrapidderivobj-t-x-rapid-type","text":"Calculate the derivative of the one-particle energy w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: de : Derivative of one-particle energy.","title":"de = calcEnergyRapidDeriv(obj, t, x, rapid, type)"},{"location":"iFluidCore/#dp-calcmomentumrapidderivobj-t-x-rapid-type","text":"Calculate the derivative of the one-particle momentum w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: dp : Derivative of one-particle momentum.","title":"dp = calcMomentumRapidDeriv(obj, t, x, rapid, type)"},{"location":"iFluidCore/#dt-calcscatteringrapidderivobj-t-x-rapid1-rapid2-type1-type2","text":"Calculate the derivative of the two-body scattering phase w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid1 : Scalar or vector indicating the (main) rapidity. rapid2 : Scalar or vector indicating the (convilution) rapidity. type1 : Scalar or vector indicating the (main) type index of the quasiparticles. type2 : Scalar or vector indicating the (convolution) type index of the quasiparticles. Returns: dT : Derivative of the two-body scattering phase. Must be an iFluidTensor .","title":"dT = calcScatteringRapidDeriv(obj, t, x, rapid1, rapid2, type1, type2)"},{"location":"iFluidCore/#de-calcenergycouplingderivobj-coupidx-t-x-rapid-type","text":"Calculate the derivative of the one-particle energy w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: de : Derivative of one-particle energy.","title":"de = calcEnergyCouplingDeriv(obj, coupIdx, t, x, rapid, type)"},{"location":"iFluidCore/#dp-calcmomentumcouplingderivobj-coupidx-t-x-rapid-type","text":"Calculate the derivative of the one-particle momentum w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: dp : Derivative of one-particle momentum.","title":"dp = calcMomentumCouplingDeriv(obj, coupIdx, t, x, rapid, type)"},{"location":"iFluidCore/#dt-calcscatteringcouplingderivobj-coupidx-t-x-rapid1-rapid2-type1-type2","text":"Calculate the derivative of the two-body scattering phase w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid1 : Scalar or vector indicating the (main) rapidity. rapid2 : Scalar or vector indicating the (convilution) rapidity. type1 : Scalar or vector indicating the (main) type index of the quasiparticles. type2 : Scalar or vector indicating the (convolution) type index of the quasiparticles. Returns: dT : Derivative of the two-body scattering phase. Must be an iFluidTensor .","title":"dT = calcScatteringCouplingDeriv(obj, coupIdx, t, x, rapid1, rapid2, type1, type2)"},{"location":"iFluidCore/#accessor-methods","text":"","title":"Accessor methods"},{"location":"iFluidCore/#setcouplingsobj-couplings","text":"Set the couplings of the model. Inputs: couplings : Cell array of couplings and their time and space derivatives.","title":"setCouplings(obj, couplings)"},{"location":"iFluidCore/#couplings-getcouplingsobj","text":"Get the couplings of the model. Returns: couplings : Cell array of couplings and their time and space derivatives.","title":"couplings = getCouplings(obj)"},{"location":"iFluidCore/#x_grid-rapid_grid-type_grid-rapid_w-getgridsobj","text":"Get all grids of the system. Returns: x_grid : Vector of M gridpoints in position space. rapid_grid : Vector of N gridpoints in rapidity space. rapid_w : Vector of N rapidity quadrature weights. type_grid : Vector from 1 to Ntypes .","title":"[x_grid, rapid_grid, type_grid, rapid_w] = getGrids(obj)"},{"location":"iFluidCore/#tba-methods","text":"","title":"TBA methods"},{"location":"iFluidCore/#q_dr-applydressingobj-q-theta-t","text":"Dress the quantity Q , threby taking into account the collective iteractions of the quasiparticles. Inputs: Q : Quantity to be dressed. Must be an iFluidTensor . theta : Filling function at time t . Must be an iFluidTensor . t : Scalar indicating the time, corresponding to theta . Returns: Q_dr : Dressed quantity as iFluidTensor .","title":"Q_dr = applyDressing(obj, Q, theta, t)"},{"location":"iFluidCore/#h_i-getoneparticleevobj-charidx-t-x-rapid","text":"Returns the one-particle eigenvalue of the i'th conserved charge. By default the 0th charge is the number operator, the 1st charge is the momentum, and the 2nd charge is the Hamiltonian. Inputs: charIdx : Scalar indicating which charge is considered. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. Returns: h_i : Matrix containing the eigenvalues.","title":"h_i = getOneParticleEV(obj, charIdx, t, x, rapid)"},{"location":"iFluidCore/#rho_t-rhos_t-transform2rhoobj-theta_t-t_array","text":"Constructs the root density and the density of states from the filling function. Inputs: theta_t : Cell array of (or single) filling functions as iFluidTensor . t_array : Vector of times corresponding to the fillings in theta_t . Returns: rho_t : Cell array of (or single) root densities as iFluidTensor . rhoS_t : Cell array of (or single) density of states as iFluidTensor .","title":"[rho_t, rhoS_t] = transform2rho(obj, theta_t, t_array)"},{"location":"iFluidCore/#theta_t-rhos_t-transform2thetaobj-rho_t-t_array","text":"Constructs the filling function and the density of states from the root density. Inputs: rho_t : Cell array of (or single) root densities as iFluidTensor . t_array : Vector of times corresponding to the root densities in rho_t . Returns: theta_t : Cell array of (or single) filling functions as iFluidTensor . rhoS_t : Cell array of (or single) density of states as iFluidTensor .","title":"[theta_t, rhoS_t] = transform2theta(obj, rho_t, t_array)"},{"location":"iFluidCore/#q-j-calcchargesobj-c_idx-theta_t-t_array","text":"Calculate the expectation values of the i'th charge densities and associated currents. Inputs: c_idx : Scalar or vector of indices indicating which charges to consider. theta_t : Cell array of (or single) filling functions as iFluidTensor . t_array : Vector of times corresponding to the fillings in theta_t . Returns: q : Matrix of charge density expectation values for times in t_array . j : Matrix of charge current expectation values for times in t_array .","title":"[q, j] = calcCharges(obj, c_idx, theta_t, t_array)"},{"location":"iFluidCore/#theta-e_eff-calcthermalstateobj-t-tba_couplings","text":"Calculates a thermal state of the model specified by the couplings and temperature. Inputs: T : Temperature. Can be either a scalar (homogeneous) or an anonymous function of x (inhomogeneous). TBA_couplings : (Optional) Cell array of couplings. If none specified, the couplings of the iFluidCore object are used instead. Returns: theta : Filling function of thermal state as iFluidTensor . e_eff : Pseudo-energy of thermal state as iFluidTensor .","title":"[theta, e_eff] = calcThermalState(obj, T, TBA_couplings)"},{"location":"iFluidCore/#v_eff-a_eff-calceffectivevelocitiesobj-theta-t-x-rapid-type","text":"Calculate the effective velocity and acceleration of the quasiparticles given the current state of the system. Inputs: theta : Filling function at time t . t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: v_eff : Effective velocity as iFluidTensor . a_eff : Effective acceleration as iFluidTensor .","title":"[v_eff, a_eff] = calcEffectiveVelocities(obj, theta, t, x, rapid, type)"},{"location":"iFluidCore/#e_eff-calceffectiveenergyobj-t-t-x-rapid","text":"Calculate the pseudo-energy of the system. Inputs: T : Temperature. Can be either a scalar (homogeneous) or an anonymous function of x (inhomogeneous). t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. Returns: e_eff : Peuso-energy as iFluidTensor .","title":"e_eff = calcEffectiveEnergy(obj, T, t, x, rapid)"},{"location":"iFluidCore/#methods-dependent-on-quasiparticle-statisitcs","text":"","title":"Methods dependent on quasiparticle statisitcs"},{"location":"iFluidCore/#f-getstatfactorobj-theta","text":"Returns the statistical factor based the statistics followed by the quasiparticles of the model. Inputs: theta : Filling function as iFluidTensor . Returns: f : Statistical factor as iFluidTensor .","title":"f = getStatFactor(obj, theta)"},{"location":"iFluidCore/#f-getfreeenergyobj-e_eff","text":"Returns the free energy function of the model based on the quasiparticle statistics. Inputs: e_eff : Pseudo-energy of the state as iFluidTensor . Returns: F : Free energy function as iFluidTensor .","title":"F = getFreeEnergy(obj, e_eff)"},{"location":"iFluidCore/#theta-calcfillingfractionobj-e_eff","text":"Calculates the filling function of a thermal state based on the quasiparticle statistics. Inputs: e_eff : Pseudo-energy of the state as iFluidTensor . Returns: theta : Filling function as iFluidTensor .","title":"theta = calcFillingFraction(obj, e_eff)"},{"location":"iFluidCore/#options","text":"The iFluidCore class takes an Options struct as argument in its constructor. The Options struct can hold the following (case sensitive!) parameters, which are transferred to the iFluidCore object upon construction. The possible options are: homoEvol (default false ): Indicates if all couplings are homogeneous. If true, a_eff will not be calculated. tolerance (default 1e-6 ): Tolerance for iterative solution for pseudo-energy. maxcount (default 100 ): Max nnumber of iterations for finding pseudo-energy.","title":"Options"},{"location":"iFluidSolver/","text":"iFluidSolver The purpose of the iFluidSolver class is to propagate the filling function in time following the hydrodynamic equation This is achieved by approximating the propagation for a single time-step dt . Note, the iFluidSolver class is abstract and must be extended by classes encoding algorithms for performing the time-step. Click here to see how to implement your own algorithm. Constructor obj = iFluidSolver(coreObj, Options) Construct an iFluidCore object containing all the information and methods of a TBA of a given model. Inputs: coreObj : iFluidCore object specifying the model and problem at hand. Options : Struct of settings. Returns: obj : iFluidSolver object. Abstract (algorithm specific) methods [theta, u, w] = initialize(obj, theta_init, u_init, w_init, t_array ) Calculates and stores all the required quantities used by the algorithm implemented in step() . Inputs: theta_init : Initial filling function (t = 0), as iFluidTensor . u_init : Initial position characteristic (t = 0), as iFluidTensor . w_init : Initial rapidity characteristic (t = 0), as iFluidTensor . t_array : Vector of timesteps. Returns: theta : Filling passed to first call of step() . Typically equal to theta_init . u : Position characteristic passed to first call of step() . Typically equal to u_init . w : Rapidity characteristic passed to first call of step() . Typically equal to w_init . [theta_next, u_next, w_next] = step(obj, theta_prev, u_prev, w_prev, t, dt) Propagates the filling function one timestep dt . Inputs: theta_prev : Filling function at time t , as iFluidTensor . u_prev : Position characteristic at time t , as iFluidTensor . w_prev : Rapidity characteristic at time t , as iFluidTensor . t : Time at the start of the step. dt : Length of step. Returns: theta_next : Filling function at time t + dt , as iFluidTensor . u_next : Position characteristic at time t + dt , as iFluidTensor . w_next : Rapidity characteristic at time t + dt , as iFluidTensor . Time propagation methods [theta_t, u_t, w_t] = propagateTheta(obj, theta_init, t_array) Propagates the filling function according to the hydrodynamical equation using the user-implemented step() method. Inputs: theta_init : Initial filling function (t = 0), as iFluidTensor . t_array : Vector of starting times of each step. Returns: theta_t : Cell array of filling functions for each time in t_array . u_t : Cell array of position characteristics for each time in t_array . w_t : Cell array of rapidity characteristics for each time in t_array . Additional methods [theta_next, u_next, w_next] = performFirstOrderStep(obj, theta_prev, u_prev, w_prev, t, dt) Propagates the filling function one timestep dt using a first-order approximation. This method is helpful for calculating the required quantities for more sophisticated step() algorithms. Inputs: theta_prev : Filling function at time t , as iFluidTensor . u_prev : Position characteristic at time t , as iFluidTensor . w_prev : Rapidity characteristic at time t , as iFluidTensor . t : Time at the start of the step. dt : Length of step. Returns: theta_next : Filling function at time t + dt , as iFluidTensor . u_next : Position characteristic at time t + dt , as iFluidTensor . w_next : Rapidity characteristic at time t + dt , as iFluidTensor . tensor_int = interpPhaseSpace(obj, tensor_grid, rapid_int, x_int, extrapFlag) Interpolates a quantity defined on the grids x_grid and rapid_grid from the stored iFluidCore object. Inputs: tensor_grid : Quantity to interpolate. Must be iFluidTensor . rapid_int : Matrix of rapidities to interpolate to. x_int : Matrix of positions to interpolate to. extrapFlag : Flag for extrapolation. If true , extrapolation is allowed. If false , all extrapolated values are 0. Returns: tensor_int : tensor_grid interpolate to rapid_int and x_int . Options The iFluidSolver class takes an Options struct as argument in its constructor. The Options struct can hold the following (case sensitive!) parameters, which are transferred to the iFluidSolver object upon construction. The possible options are: extrapFlag (default false ): Indicates if extrapolation is allowed. periodRapid (default false ): Indicates if rapidity is periodic.","title":"iFluidSolver"},{"location":"iFluidSolver/#ifluidsolver","text":"The purpose of the iFluidSolver class is to propagate the filling function in time following the hydrodynamic equation This is achieved by approximating the propagation for a single time-step dt . Note, the iFluidSolver class is abstract and must be extended by classes encoding algorithms for performing the time-step. Click here to see how to implement your own algorithm.","title":"iFluidSolver"},{"location":"iFluidSolver/#constructor","text":"","title":"Constructor"},{"location":"iFluidSolver/#obj-ifluidsolvercoreobj-options","text":"Construct an iFluidCore object containing all the information and methods of a TBA of a given model. Inputs: coreObj : iFluidCore object specifying the model and problem at hand. Options : Struct of settings. Returns: obj : iFluidSolver object.","title":"obj = iFluidSolver(coreObj, Options)"},{"location":"iFluidSolver/#abstract-algorithm-specific-methods","text":"","title":"Abstract (algorithm specific) methods"},{"location":"iFluidSolver/#theta-u-w-initializeobj-theta_init-u_init-w_init-t_array","text":"Calculates and stores all the required quantities used by the algorithm implemented in step() . Inputs: theta_init : Initial filling function (t = 0), as iFluidTensor . u_init : Initial position characteristic (t = 0), as iFluidTensor . w_init : Initial rapidity characteristic (t = 0), as iFluidTensor . t_array : Vector of timesteps. Returns: theta : Filling passed to first call of step() . Typically equal to theta_init . u : Position characteristic passed to first call of step() . Typically equal to u_init . w : Rapidity characteristic passed to first call of step() . Typically equal to w_init .","title":"[theta, u, w] = initialize(obj, theta_init, u_init, w_init, t_array )"},{"location":"iFluidSolver/#theta_next-u_next-w_next-stepobj-theta_prev-u_prev-w_prev-t-dt","text":"Propagates the filling function one timestep dt . Inputs: theta_prev : Filling function at time t , as iFluidTensor . u_prev : Position characteristic at time t , as iFluidTensor . w_prev : Rapidity characteristic at time t , as iFluidTensor . t : Time at the start of the step. dt : Length of step. Returns: theta_next : Filling function at time t + dt , as iFluidTensor . u_next : Position characteristic at time t + dt , as iFluidTensor . w_next : Rapidity characteristic at time t + dt , as iFluidTensor .","title":"[theta_next, u_next, w_next] = step(obj, theta_prev, u_prev, w_prev, t, dt)"},{"location":"iFluidSolver/#time-propagation-methods","text":"","title":"Time propagation methods"},{"location":"iFluidSolver/#theta_t-u_t-w_t-propagatethetaobj-theta_init-t_array","text":"Propagates the filling function according to the hydrodynamical equation using the user-implemented step() method. Inputs: theta_init : Initial filling function (t = 0), as iFluidTensor . t_array : Vector of starting times of each step. Returns: theta_t : Cell array of filling functions for each time in t_array . u_t : Cell array of position characteristics for each time in t_array . w_t : Cell array of rapidity characteristics for each time in t_array .","title":"[theta_t, u_t, w_t] = propagateTheta(obj, theta_init, t_array)"},{"location":"iFluidSolver/#additional-methods","text":"","title":"Additional methods"},{"location":"iFluidSolver/#theta_next-u_next-w_next-performfirstorderstepobj-theta_prev-u_prev-w_prev-t-dt","text":"Propagates the filling function one timestep dt using a first-order approximation. This method is helpful for calculating the required quantities for more sophisticated step() algorithms. Inputs: theta_prev : Filling function at time t , as iFluidTensor . u_prev : Position characteristic at time t , as iFluidTensor . w_prev : Rapidity characteristic at time t , as iFluidTensor . t : Time at the start of the step. dt : Length of step. Returns: theta_next : Filling function at time t + dt , as iFluidTensor . u_next : Position characteristic at time t + dt , as iFluidTensor . w_next : Rapidity characteristic at time t + dt , as iFluidTensor .","title":"[theta_next, u_next, w_next] = performFirstOrderStep(obj, theta_prev, u_prev, w_prev, t, dt)"},{"location":"iFluidSolver/#tensor_int-interpphasespaceobj-tensor_grid-rapid_int-x_int-extrapflag","text":"Interpolates a quantity defined on the grids x_grid and rapid_grid from the stored iFluidCore object. Inputs: tensor_grid : Quantity to interpolate. Must be iFluidTensor . rapid_int : Matrix of rapidities to interpolate to. x_int : Matrix of positions to interpolate to. extrapFlag : Flag for extrapolation. If true , extrapolation is allowed. If false , all extrapolated values are 0. Returns: tensor_int : tensor_grid interpolate to rapid_int and x_int .","title":"tensor_int = interpPhaseSpace(obj, tensor_grid, rapid_int, x_int, extrapFlag)"},{"location":"iFluidSolver/#options","text":"The iFluidSolver class takes an Options struct as argument in its constructor. The Options struct can hold the following (case sensitive!) parameters, which are transferred to the iFluidSolver object upon construction. The possible options are: extrapFlag (default false ): Indicates if extrapolation is allowed. periodRapid (default false ): Indicates if rapidity is periodic.","title":"Options"},{"location":"model/","text":"Implementing a new model This example demonstrates how to implement a model in iFluid. The model The model in question is not a real integrable model - it merely serves as a demonstration. The implementation of a model essentially consists of programming its thermodynamic Bethe ansatz. For that we need the single particle energy and momentum along with the two-body scattering phase: where j denotes the quasiparticle type, while A and B are the couplings of our model. Furhtermore, let's assume the quasiparticles of our model to follow fermionic statistics. Defining the class Create a new model by extending the iFluidCore class. classdef myModel iFluidCore The constructor of our model class simply calls the constructor of the iFluidCore class. function obj = myModel(x_grid, rapid_grid, rapid_w, couplings, Options) obj = obj@iFluidCore(x_grid, rapid_grid, rapid_w, couplings, Ntypes, Options); end Implementing the TBA Next we must implement the abstract properties and methods of the iFluidCore class. First we specify the quasipaticle statistics: properties (Access = protected) quasiSpecies = 'fermion'; end Next we must implement the energy, momentum and two-body scattering phase of our model along with their derivatives w.r.t. the rapidity: function ebare = getBareEnergy(obj, t, x, rapid, type) % We take B to be the second coupling ebare = rapid.^2 + j.*obj.couplings{1,2}(t,x); end function pbare = getBareMomentum(obj, t, x, rapid, type) pbare = 4*rapid; end function de = calcEnergyRapidDeriv(obj, t, x, rapid, type) de = 2*rapid; end function dp = calcMomentumRapidDeriv(obj, t, x, rapid, type) % We should return something of same length as rapid dp = repmat(4, length(rapid), 1); end function dT = calcScatteringRapidDeriv(obj, t, x, rapid1, rapid2, type1, type2) % Reshape input to ensure right dimensions rapid1 = reshape(rapid1, length(rapid1), 1); % rapid1 is 1st index rapid2 = reshape(rapid2, 1, length(rapid2)); % rapid2 is 2nd index type1 = reshape(type1, 1, 1, length(type1)); % type1 is 3rd index type2 = reshape(type2, 1, 1, 1, length(type2)); % type2 is 4th index % We take A to be the first coupling dT = (type1-type2).*obj.couplings{1,1}(t,x)./( (rapid1-rapid2).^2 + obj.couplings{1,1}(t,x).^2 ); % Scattering kernel should be returned as an iFluidTensor dT = iFluidTensor(dT); end Note that all operations in general should be elementwise, as x , lambda and type are most often vectors. Finally, we have to implement functions providing the derivatives w.r.t. the couplings A and B : function de = calcEnergyCouplingDeriv(obj, coupIdx, t, x, rapid, type) if coupIdx == 1 % Derivative w.r.t. A de = 0; else % Derivative w.r.t. B de = repmat( type, length(rapid), 1); end end function dp = calcMomentumCouplingDeriv(obj, coupIdx, t, x, rapid, type) if coupIdx == 1 % Derivative w.r.t. A dp = 0; else % Derivative w.r.t. B dp = 0; end end function dT = calcScatteringCouplingDeriv(obj, coupIdx, t, x, rapid1, rapid2, type1, type2) % Reshape input to ensure right dimensions rapid1 = reshape(rapid1, length(rapid1), 1); % rapid1 is 1st index rapid2 = reshape(rapid2, 1, length(rapid2)); % rapid2 is 2nd index type1 = reshape(type1, 1, 1, length(type1)); % type1 is 3rd index type2 = reshape(type2, 1, 1, 1, length(type2)); % type2 is 4th index if coupIdx == 1 % Derivative w.r.t. A dT = -(type1-type2).*(rapid1-rapid2)./( (rapid1-rapid2).^2 + obj.couplings{1,1}(t,x).^2 ); else % Derivative w.r.t. B dT = 0; end dT = iFluidTensor(dT); end And that's it! We have now implemented our own model, which is fully integrated in the iFluid framework.","title":"Implementing a new model"},{"location":"model/#implementing-a-new-model","text":"This example demonstrates how to implement a model in iFluid.","title":"Implementing a new model"},{"location":"model/#the-model","text":"The model in question is not a real integrable model - it merely serves as a demonstration. The implementation of a model essentially consists of programming its thermodynamic Bethe ansatz. For that we need the single particle energy and momentum along with the two-body scattering phase: where j denotes the quasiparticle type, while A and B are the couplings of our model. Furhtermore, let's assume the quasiparticles of our model to follow fermionic statistics.","title":"The model"},{"location":"model/#defining-the-class","text":"Create a new model by extending the iFluidCore class. classdef myModel iFluidCore The constructor of our model class simply calls the constructor of the iFluidCore class. function obj = myModel(x_grid, rapid_grid, rapid_w, couplings, Options) obj = obj@iFluidCore(x_grid, rapid_grid, rapid_w, couplings, Ntypes, Options); end","title":"Defining the class"},{"location":"model/#implementing-the-tba","text":"Next we must implement the abstract properties and methods of the iFluidCore class. First we specify the quasipaticle statistics: properties (Access = protected) quasiSpecies = 'fermion'; end Next we must implement the energy, momentum and two-body scattering phase of our model along with their derivatives w.r.t. the rapidity: function ebare = getBareEnergy(obj, t, x, rapid, type) % We take B to be the second coupling ebare = rapid.^2 + j.*obj.couplings{1,2}(t,x); end function pbare = getBareMomentum(obj, t, x, rapid, type) pbare = 4*rapid; end function de = calcEnergyRapidDeriv(obj, t, x, rapid, type) de = 2*rapid; end function dp = calcMomentumRapidDeriv(obj, t, x, rapid, type) % We should return something of same length as rapid dp = repmat(4, length(rapid), 1); end function dT = calcScatteringRapidDeriv(obj, t, x, rapid1, rapid2, type1, type2) % Reshape input to ensure right dimensions rapid1 = reshape(rapid1, length(rapid1), 1); % rapid1 is 1st index rapid2 = reshape(rapid2, 1, length(rapid2)); % rapid2 is 2nd index type1 = reshape(type1, 1, 1, length(type1)); % type1 is 3rd index type2 = reshape(type2, 1, 1, 1, length(type2)); % type2 is 4th index % We take A to be the first coupling dT = (type1-type2).*obj.couplings{1,1}(t,x)./( (rapid1-rapid2).^2 + obj.couplings{1,1}(t,x).^2 ); % Scattering kernel should be returned as an iFluidTensor dT = iFluidTensor(dT); end Note that all operations in general should be elementwise, as x , lambda and type are most often vectors. Finally, we have to implement functions providing the derivatives w.r.t. the couplings A and B : function de = calcEnergyCouplingDeriv(obj, coupIdx, t, x, rapid, type) if coupIdx == 1 % Derivative w.r.t. A de = 0; else % Derivative w.r.t. B de = repmat( type, length(rapid), 1); end end function dp = calcMomentumCouplingDeriv(obj, coupIdx, t, x, rapid, type) if coupIdx == 1 % Derivative w.r.t. A dp = 0; else % Derivative w.r.t. B dp = 0; end end function dT = calcScatteringCouplingDeriv(obj, coupIdx, t, x, rapid1, rapid2, type1, type2) % Reshape input to ensure right dimensions rapid1 = reshape(rapid1, length(rapid1), 1); % rapid1 is 1st index rapid2 = reshape(rapid2, 1, length(rapid2)); % rapid2 is 2nd index type1 = reshape(type1, 1, 1, length(type1)); % type1 is 3rd index type2 = reshape(type2, 1, 1, 1, length(type2)); % type2 is 4th index if coupIdx == 1 % Derivative w.r.t. A dT = -(type1-type2).*(rapid1-rapid2)./( (rapid1-rapid2).^2 + obj.couplings{1,1}(t,x).^2 ); else % Derivative w.r.t. B dT = 0; end dT = iFluidTensor(dT); end And that's it! We have now implemented our own model, which is fully integrated in the iFluid framework.","title":"Implementing the TBA"},{"location":"solver/","text":"Implementing a new solver This example demonstrates how to implement a first-order stepper to solve the GHD equation: The new solver must extend the iFluidSolver class and implement the abstract methods step() and initialize() . The equation above admidts the implicit solution where the trajectories are given by and The equations for the trajectories are also implicit, as the effective velcity and acceleration depends on the state of the system at the given time. The solver presented in this example provides a first-order approximation to the trajectories. The algorithm The iFluid solvers must provide a solution for a single time-step To first order we approximate the trajectories as and Defining the class Create a new solver by extending the iFluidSolver class. classdef FirstOrderSolver iFluidSolver Quantities like the effective and velocity and acceleration are calculated in the iFluidCore class. Therefore, we must pass an object of said class to our solver upon instantiation and store it for future use. This is taken care of by passing the object to the superclass constructor: function obj = FirstOrderSolver(coreObj, Options) obj = obj@iFluidSolver(coreObj, Options); end Implementing the stepper Next, we implement the abstract method step() , which propagates our system a single time step. function [theta_next, u_next, w_next] = performFirstOrderStep(obj, theta_prev, u_prev, w_prev, t, dt) [v_eff, a_eff] = obj.coreObj.calcEffectiveVelocities(theta_prev, t, obj.x_grid, obj.rapid_grid, obj.type_grid); x_tilde = obj.x_grid - dt*v_eff; r_tilde = obj.rapid_grid - dt*a_eff; theta_next = obj.interpPhaseSpace(theta_prev, r_tilde, x_tilde, obj.extrapFlag); u_next = obj.interpPhaseSpace(u_prev, r_tilde, x_tilde, true ); % always extrapolate u w_next = obj.interpPhaseSpace(w_prev, r_tilde, x_tilde, true ); % always extrapolate u end The method interpPhaseSpace() takes care of interpolating a quantity defined on the pre-specified grids to the points of the trajectories. Implementing the initializer Finally, we have the implement the abstract method initialize() , which prepares any quantities needed for the first time step to proceed. The first order algorithm specified here does not require such quantities. Therefore, we don't have to do anything special in the initialize() method. function [theta, u, w] = initialize(obj, theta_init, u_init, w_init, t_array) theta = theta_init; u = u_init; w = w_init; end Application Once the steps above are completed, the newly implemented solver can be instantiated and used for solving the GHD equation: Solver1 = FirstOrderSolver( someModel ); theta_t = Solver1.propagateTheta( theta_init, t_array ); Related: How to implement you own model","title":"Implementing a new algorithm"},{"location":"solver/#implementing-a-new-solver","text":"This example demonstrates how to implement a first-order stepper to solve the GHD equation: The new solver must extend the iFluidSolver class and implement the abstract methods step() and initialize() . The equation above admidts the implicit solution where the trajectories are given by and The equations for the trajectories are also implicit, as the effective velcity and acceleration depends on the state of the system at the given time. The solver presented in this example provides a first-order approximation to the trajectories.","title":"Implementing a new solver"},{"location":"solver/#the-algorithm","text":"The iFluid solvers must provide a solution for a single time-step To first order we approximate the trajectories as and","title":"The algorithm"},{"location":"solver/#defining-the-class","text":"Create a new solver by extending the iFluidSolver class. classdef FirstOrderSolver iFluidSolver Quantities like the effective and velocity and acceleration are calculated in the iFluidCore class. Therefore, we must pass an object of said class to our solver upon instantiation and store it for future use. This is taken care of by passing the object to the superclass constructor: function obj = FirstOrderSolver(coreObj, Options) obj = obj@iFluidSolver(coreObj, Options); end","title":"Defining the class"},{"location":"solver/#implementing-the-stepper","text":"Next, we implement the abstract method step() , which propagates our system a single time step. function [theta_next, u_next, w_next] = performFirstOrderStep(obj, theta_prev, u_prev, w_prev, t, dt) [v_eff, a_eff] = obj.coreObj.calcEffectiveVelocities(theta_prev, t, obj.x_grid, obj.rapid_grid, obj.type_grid); x_tilde = obj.x_grid - dt*v_eff; r_tilde = obj.rapid_grid - dt*a_eff; theta_next = obj.interpPhaseSpace(theta_prev, r_tilde, x_tilde, obj.extrapFlag); u_next = obj.interpPhaseSpace(u_prev, r_tilde, x_tilde, true ); % always extrapolate u w_next = obj.interpPhaseSpace(w_prev, r_tilde, x_tilde, true ); % always extrapolate u end The method interpPhaseSpace() takes care of interpolating a quantity defined on the pre-specified grids to the points of the trajectories.","title":"Implementing the stepper"},{"location":"solver/#implementing-the-initializer","text":"Finally, we have the implement the abstract method initialize() , which prepares any quantities needed for the first time step to proceed. The first order algorithm specified here does not require such quantities. Therefore, we don't have to do anything special in the initialize() method. function [theta, u, w] = initialize(obj, theta_init, u_init, w_init, t_array) theta = theta_init; u = u_init; w = w_init; end","title":"Implementing the initializer"},{"location":"solver/#application","text":"Once the steps above are completed, the newly implemented solver can be instantiated and used for solving the GHD equation: Solver1 = FirstOrderSolver( someModel ); theta_t = Solver1.propagateTheta( theta_init, t_array ); Related: How to implement you own model","title":"Application"}]}