{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"iFluid (intergrable-Fluid) is an open-source Matlab framework for simulating the dynamics of integrable models using the theory of generalized hydrodynamics. The framework is actively being used in research and is continuously being updated. Latest version v2.1 ( changelog ) Download/clone from Github Bug reports code Please cite the introductory iFluid paper Contact frederik.moller(at)tuwien.ac.at Getting started Simply clone the iFluid Github repository . To test that everything is working, try running some of the scripts found in the \\Examples folder. For more information regarding the theory of generalized hydrodynamics, please refer to the introductory iFluid paper . Project tree The full project tree with all the iFluid specific files can be seen below. . \u251c\u2500\u2500 iFluid \u2502 \u251c\u2500\u2500 fluidcell.m \u2502 \u251c\u2500\u2500 iFluidSolver.m \u2502 \u2514\u2500\u2500 iFLuidCore.m \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 LiebLinigerModel.m \u2502 \u251c\u2500\u2500 LiebLinigerModel_SI.m \u2502 \u251c\u2500\u2500 HardRodModel.m \u2502 \u251c\u2500\u2500 sinhGordonModel.m \u2502 \u2514\u2500\u2500 XXZchainModel.m \u251c\u2500\u2500 solvers \u2502 \u251c\u2500\u2500 FirstOrderSolver.m \u2502 \u251c\u2500\u2500 SecondSolver.m \u2502 \u251c\u2500\u2500 CollisionSolver.m \u2502 \u251c\u2500\u2500 DiffusionSolver.m \u2502 \u2514\u2500\u2500 LinearDiffusionSolver.m \u251c\u2500\u2500 modules \u2502 \u2514\u2500\u2500 CorrelationModule.m \u251c\u2500\u2500 Examples \u2502 \u251c\u2500\u2500 LiebLinigerExample.m \u2502 \u251c\u2500\u2500 LiebLinigerExample2.m \u2502 \u251c\u2500\u2500 sinhGordonExample.m \u2502 \u251c\u2500\u2500 XXZchainExample.m \u2502 \u2514\u2500\u2500 CorrelationExample.m \u2514\u2500\u2500 utils Become a contributor iFluid is an open-source project, whereby anyone can contribute to the code base. A contribution could be anything from a small bug fix to addition of new models or algorithms. To become a contributor yourself, simply follow these simple steps: Create a Github account and fork the code repository . This will create your own personal copy of the code base. Make your edits and additions to the code and commit them. Please include a message at every commit detailing the changes to the code. The messages can be written using the command git commit -m \"your message here\" . Push your changes to your personal repository. Afterwards, create a pull request , which allows us to review the code and merge the changes into the main repo. Be aware that we might add comments or edits to your pull request. Once the contribution is approved, it will be instantly included in the iFluid code base!","title":"Home"},{"location":"#getting-started","text":"Simply clone the iFluid Github repository . To test that everything is working, try running some of the scripts found in the \\Examples folder. For more information regarding the theory of generalized hydrodynamics, please refer to the introductory iFluid paper .","title":"Getting started"},{"location":"#project-tree","text":"The full project tree with all the iFluid specific files can be seen below. . \u251c\u2500\u2500 iFluid \u2502 \u251c\u2500\u2500 fluidcell.m \u2502 \u251c\u2500\u2500 iFluidSolver.m \u2502 \u2514\u2500\u2500 iFLuidCore.m \u251c\u2500\u2500 models \u2502 \u251c\u2500\u2500 LiebLinigerModel.m \u2502 \u251c\u2500\u2500 LiebLinigerModel_SI.m \u2502 \u251c\u2500\u2500 HardRodModel.m \u2502 \u251c\u2500\u2500 sinhGordonModel.m \u2502 \u2514\u2500\u2500 XXZchainModel.m \u251c\u2500\u2500 solvers \u2502 \u251c\u2500\u2500 FirstOrderSolver.m \u2502 \u251c\u2500\u2500 SecondSolver.m \u2502 \u251c\u2500\u2500 CollisionSolver.m \u2502 \u251c\u2500\u2500 DiffusionSolver.m \u2502 \u2514\u2500\u2500 LinearDiffusionSolver.m \u251c\u2500\u2500 modules \u2502 \u2514\u2500\u2500 CorrelationModule.m \u251c\u2500\u2500 Examples \u2502 \u251c\u2500\u2500 LiebLinigerExample.m \u2502 \u251c\u2500\u2500 LiebLinigerExample2.m \u2502 \u251c\u2500\u2500 sinhGordonExample.m \u2502 \u251c\u2500\u2500 XXZchainExample.m \u2502 \u2514\u2500\u2500 CorrelationExample.m \u2514\u2500\u2500 utils","title":"Project tree"},{"location":"#become-a-contributor","text":"iFluid is an open-source project, whereby anyone can contribute to the code base. A contribution could be anything from a small bug fix to addition of new models or algorithms. To become a contributor yourself, simply follow these simple steps: Create a Github account and fork the code repository . This will create your own personal copy of the code base. Make your edits and additions to the code and commit them. Please include a message at every commit detailing the changes to the code. The messages can be written using the command git commit -m \"your message here\" . Push your changes to your personal repository. Afterwards, create a pull request , which allows us to review the code and merge the changes into the main repo. Be aware that we might add comments or edits to your pull request. Once the contribution is approved, it will be instantly included in the iFluid code base!","title":"Become a contributor"},{"location":"LLexample/","text":"Example: Bose gas in expanding box potential In the iFluid github repository several example codes can be found. Here we go through one of the examples of a 1-dimensional Bose gas in an expanding box potential, which is described by the Lieb-Liniger model. As the box slowly expands the particles do \"work\" and lose kinetic energy, which effectively cools the gas. For a review of the physics of generalized hydrodynamics please refer to the introductory iFluid paper , which includes a review of the theory. Setting up and performing the calculation First, we specify all the grids used in the simulation. These should be large enough to encompass the entire filling function i.e. there should be no quasiparticles at the grid edges. Note, this is not always the case. If the system extends beyond the grids, one should enable extrapolation via the Options arguments in the iFluidSolver class. However, this is only recommended if the system is homogeneous beyond the grids! N = 2^6; % number of rapidity gridpoints M = 2^7; % number of spatial gridpoints dt = 0.025; % length of timestep rmax = 5; % max rapidity xmax = 10; % max posistion tmax = 8; % max time [r_array,rw]= legzo(N, -rmax, rmax); % rapidity grid and weights x_array = linspace(-xmax, xmax, M); % position grid t_array = linspace(0, tmax, tmax/dt+1); % array of timesteps Next, we specity the couplings of the model, namely the chemical potential and the interaction strength. In this example we keep the interaction strength constant at 1, Meanwhile, the chemical potential is a constant value minus the external potential. The external potential is a box with smooth edges realized using tanh() functions. Additionally, the box expands in time by moving the edges. The overall expression for the potential is a little cumbersome, so we utilize Matlabs symbolic toolbox to take derivatives for us. The couplings must be declared as anonymous functions with the handle @(t,x) and stored in a cell array along with their derivatives. The cell array must be structured as follows: coupling 1 coupling 2 ... coupling function temporal derivative spatial derivative In the case of the Lieb-Liniger model, the first coupling is the chemical potential, while the second coupling is the interaction strength. Note, the coupling derivatives can be left empty if the derivative is zero. Thus, the couplings are declared as follows: syms x t % symbolic chemical potential mu = 2 - 17*( -tanh(0.75*(x + 4 + 4*tanh(0.3*t) )) + ... tanh(0.75*(x - 4 - 4*tanh(0.3*t))) + 2); mu_func = matlabFunction( mu ); % convert to anonymous function dmu_dt = matlabFunction( diff(mu,t) ); % take temporal derivative dmu_dx = matlabFunction( diff(mu,x) ); % take spatial derivative couplings = { mu_func , @(t,x) 1 ; % coupling dmu_dt , [] ; % d/dt coupling dmu_dx , [] }; % d/dx coupling T = 4; % temperature Having specified the problem, we are now ready to simulate the dynamics of the system. To do so we must initialize a LiebLinigerModel object for the TBA of the model along with an iFluidSolver object for solving the GHD equations. In this case we choose the SecondOrderSolver class. As the initial state of the system we choose a thermal state. Since the quasiparticles of the Lieb-Liniger model are Fermions, the thermal state is a state obeying Fermi-Dirac statistics. % Initialize TBA for the Lieb-Liniger model LLS = LiebLinigerModel(x_array, r_array, rw, couplings); % Intialize second order solver of the GHD equation Solver2 = SecondOrderSolver(LLS, []); % Calculate thermal state at temperature T theta_init = LLS.calcThermalState(T); % Propagate intial state according to the couplings theta_t = Solver2.propagateTheta(theta_init, t_array); The last line of code calculates the filling function at every timestep in t_array . The output is a cell array, where every entry is the filling function stored in an fluidcell . Finally, we wish to calculate the atomic density of the Bosonic gas along with its kinetic energy. The function calcCharges() calculates the charge-density of the i 'th conserved charge. By convention, the number operator is the 0th charge, while the Hamiltonian is the 2nd charge. To get only the kinetic energy we simply set the potential to zero before calculating the densities. % Set potential to zero, to only get kinetic contribution to energy LLS.setCouplings( {@(t,x) 0 , @(t,x) 1} ); % Atomic density (charge index = 0), etomic density (charge index = 2) q_t = LLS.calcCharges([0 2], theta_t, t_array); The output q_t is a 3-dimenional matrix, where the first index is space, 2nd index is time, and 3rd index is charge. Plotting the results To illustrate the result of the calculation we plot selected quantities. The code for plotting will not be shown here, but can be found in the example code in the git repository. First, it is nice to see the initial filling function along with the final one. The filling function is the density of occupied states over the density of total state. As the quasiparticles of the Lieb-Liniger model are fermions, the filling will be between 0 and 1. Initially the system is confined to a small box, however, the gas moves outwards as the box expands. Additionally, the states with high rapidity become depopulated during the expansion, as quasiparticles lose kinetic energy by performing \"work\" on the sides of the box. Note, how the filling is always zero at the edges of the grid - exactly how we wanted it! Next, we plot the atomic density along with the external potential. As the box expands, so does the gas. If one increases the expasion speed of the box, the gas will not be able to cool down as efficiently. Finally, we plot the total kinetic energy by integrating over the kinetic energy density. The figure clearly shows how the gas loses kinetic energy during the expansion, and how it settles to a steady level in the end. Since the final kinetic energy is lower than the initial and remains constant, the gas has been effectively cooled.","title":"Running an iFluid calculation"},{"location":"LLexample/#example-bose-gas-in-expanding-box-potential","text":"In the iFluid github repository several example codes can be found. Here we go through one of the examples of a 1-dimensional Bose gas in an expanding box potential, which is described by the Lieb-Liniger model. As the box slowly expands the particles do \"work\" and lose kinetic energy, which effectively cools the gas. For a review of the physics of generalized hydrodynamics please refer to the introductory iFluid paper , which includes a review of the theory.","title":"Example: Bose gas in expanding box potential"},{"location":"LLexample/#setting-up-and-performing-the-calculation","text":"First, we specify all the grids used in the simulation. These should be large enough to encompass the entire filling function i.e. there should be no quasiparticles at the grid edges. Note, this is not always the case. If the system extends beyond the grids, one should enable extrapolation via the Options arguments in the iFluidSolver class. However, this is only recommended if the system is homogeneous beyond the grids! N = 2^6; % number of rapidity gridpoints M = 2^7; % number of spatial gridpoints dt = 0.025; % length of timestep rmax = 5; % max rapidity xmax = 10; % max posistion tmax = 8; % max time [r_array,rw]= legzo(N, -rmax, rmax); % rapidity grid and weights x_array = linspace(-xmax, xmax, M); % position grid t_array = linspace(0, tmax, tmax/dt+1); % array of timesteps Next, we specity the couplings of the model, namely the chemical potential and the interaction strength. In this example we keep the interaction strength constant at 1, Meanwhile, the chemical potential is a constant value minus the external potential. The external potential is a box with smooth edges realized using tanh() functions. Additionally, the box expands in time by moving the edges. The overall expression for the potential is a little cumbersome, so we utilize Matlabs symbolic toolbox to take derivatives for us. The couplings must be declared as anonymous functions with the handle @(t,x) and stored in a cell array along with their derivatives. The cell array must be structured as follows: coupling 1 coupling 2 ... coupling function temporal derivative spatial derivative In the case of the Lieb-Liniger model, the first coupling is the chemical potential, while the second coupling is the interaction strength. Note, the coupling derivatives can be left empty if the derivative is zero. Thus, the couplings are declared as follows: syms x t % symbolic chemical potential mu = 2 - 17*( -tanh(0.75*(x + 4 + 4*tanh(0.3*t) )) + ... tanh(0.75*(x - 4 - 4*tanh(0.3*t))) + 2); mu_func = matlabFunction( mu ); % convert to anonymous function dmu_dt = matlabFunction( diff(mu,t) ); % take temporal derivative dmu_dx = matlabFunction( diff(mu,x) ); % take spatial derivative couplings = { mu_func , @(t,x) 1 ; % coupling dmu_dt , [] ; % d/dt coupling dmu_dx , [] }; % d/dx coupling T = 4; % temperature Having specified the problem, we are now ready to simulate the dynamics of the system. To do so we must initialize a LiebLinigerModel object for the TBA of the model along with an iFluidSolver object for solving the GHD equations. In this case we choose the SecondOrderSolver class. As the initial state of the system we choose a thermal state. Since the quasiparticles of the Lieb-Liniger model are Fermions, the thermal state is a state obeying Fermi-Dirac statistics. % Initialize TBA for the Lieb-Liniger model LLS = LiebLinigerModel(x_array, r_array, rw, couplings); % Intialize second order solver of the GHD equation Solver2 = SecondOrderSolver(LLS, []); % Calculate thermal state at temperature T theta_init = LLS.calcThermalState(T); % Propagate intial state according to the couplings theta_t = Solver2.propagateTheta(theta_init, t_array); The last line of code calculates the filling function at every timestep in t_array . The output is a cell array, where every entry is the filling function stored in an fluidcell . Finally, we wish to calculate the atomic density of the Bosonic gas along with its kinetic energy. The function calcCharges() calculates the charge-density of the i 'th conserved charge. By convention, the number operator is the 0th charge, while the Hamiltonian is the 2nd charge. To get only the kinetic energy we simply set the potential to zero before calculating the densities. % Set potential to zero, to only get kinetic contribution to energy LLS.setCouplings( {@(t,x) 0 , @(t,x) 1} ); % Atomic density (charge index = 0), etomic density (charge index = 2) q_t = LLS.calcCharges([0 2], theta_t, t_array); The output q_t is a 3-dimenional matrix, where the first index is space, 2nd index is time, and 3rd index is charge.","title":"Setting up and performing the calculation"},{"location":"LLexample/#plotting-the-results","text":"To illustrate the result of the calculation we plot selected quantities. The code for plotting will not be shown here, but can be found in the example code in the git repository. First, it is nice to see the initial filling function along with the final one. The filling function is the density of occupied states over the density of total state. As the quasiparticles of the Lieb-Liniger model are fermions, the filling will be between 0 and 1. Initially the system is confined to a small box, however, the gas moves outwards as the box expands. Additionally, the states with high rapidity become depopulated during the expansion, as quasiparticles lose kinetic energy by performing \"work\" on the sides of the box. Note, how the filling is always zero at the edges of the grid - exactly how we wanted it! Next, we plot the atomic density along with the external potential. As the box expands, so does the gas. If one increases the expasion speed of the box, the gas will not be able to cool down as efficiently. Finally, we plot the total kinetic energy by integrating over the kinetic energy density. The figure clearly shows how the gas loses kinetic energy during the expansion, and how it settles to a steady level in the end. Since the final kinetic energy is lower than the initial and remains constant, the gas has been effectively cooled.","title":"Plotting the results"},{"location":"LLmodel/","text":"","title":"LLmodel"},{"location":"Models/","text":"Implemented models iFluid implements a variety of integrable models, which are all listed below. For a full documentations of the solvers we refer to the source code. For a guide on how to implement your own model, see here . Lieb-Liniger model XXZ-chain model Relativistic sinh-Gordon model Classical hard rod model","title":"Implemented models"},{"location":"Models/#implemented-models","text":"iFluid implements a variety of integrable models, which are all listed below. For a full documentations of the solvers we refer to the source code. For a guide on how to implement your own model, see here .","title":"Implemented models"},{"location":"Models/#lieb-liniger-model","text":"","title":"Lieb-Liniger model"},{"location":"Models/#xxz-chain-model","text":"","title":"XXZ-chain model"},{"location":"Models/#relativistic-sinh-gordon-model","text":"","title":"Relativistic sinh-Gordon model"},{"location":"Models/#classical-hard-rod-model","text":"","title":"Classical hard rod model"},{"location":"Solvers/","text":"Solvers for GHD propagation equation iFluid implements a variety of solvers for solver the Euler-scale continuity equation or modifications thereof. Here we list the solvers currently implemented in iFluid. For a full documentations of the solvers we refer to the source code. For a guide on how to implement your own solver, see here . First order Euler solver Simple first order solver of the Euler-scale propagation equation Implemented in the FirstOrderSolver class. Second order Euler solver Second order solver of the Euler-scale propagation equation Implemented in the SecondOrderSolver class. More information regarding the method here . Diffusion solver Solves the Euler-scale propagation equation with diffusion term Implemented in the DiffusionSolver class. Linearized diffusion solver Solves the linearized diffusion equation with no inhomogeneous couplings The solver propagates a small perturbation on top of a homogeneous background. Implemented in the LinearDiffusionSolver class. More information regarding the method here . Collision integral solver (dimensional crossover) Solves the Euler-scale propagation equation with added collision integral Currently this class only works for the Lieb-Liniger model in the dimensional crossover regime. The collision integral takes into account collision with transverse excited atoms breaking the integrability of the model. Implemented in the CollisionSolver class. More information regarding the method here .","title":"Implemented solvers"},{"location":"Solvers/#solvers-for-ghd-propagation-equation","text":"iFluid implements a variety of solvers for solver the Euler-scale continuity equation or modifications thereof. Here we list the solvers currently implemented in iFluid. For a full documentations of the solvers we refer to the source code. For a guide on how to implement your own solver, see here .","title":"Solvers for GHD propagation equation"},{"location":"Solvers/#first-order-euler-solver","text":"Simple first order solver of the Euler-scale propagation equation Implemented in the FirstOrderSolver class.","title":"First order Euler solver"},{"location":"Solvers/#second-order-euler-solver","text":"Second order solver of the Euler-scale propagation equation Implemented in the SecondOrderSolver class. More information regarding the method here .","title":"Second order Euler solver"},{"location":"Solvers/#diffusion-solver","text":"Solves the Euler-scale propagation equation with diffusion term Implemented in the DiffusionSolver class.","title":"Diffusion solver"},{"location":"Solvers/#linearized-diffusion-solver","text":"Solves the linearized diffusion equation with no inhomogeneous couplings The solver propagates a small perturbation on top of a homogeneous background. Implemented in the LinearDiffusionSolver class. More information regarding the method here .","title":"Linearized diffusion solver"},{"location":"Solvers/#collision-integral-solver-dimensional-crossover","text":"Solves the Euler-scale propagation equation with added collision integral Currently this class only works for the Lieb-Liniger model in the dimensional crossover regime. The collision integral takes into account collision with transverse excited atoms breaking the integrability of the model. Implemented in the CollisionSolver class. More information regarding the method here .","title":"Collision integral solver (dimensional crossover)"},{"location":"changelog/","text":"Version 2.1 Changed the way optional inputs are parsed in the function calcCharges . To calculate the one-particle form factors, call calcCharges(..., 'calc_formfactors', true) . To obtain the individual charges and currents for each quasi-particle type, call calcCharges(..., 'sum_types', false) . Version 2.0 Class iFluidTensor has changed name to fluidcell to better reflect its physical meaning. The data structure now has a clearer and readable constructor. The data can now be referenced and assigned similar to regular Matlab arrays. Added support for trigonometric functions. Added support for 1D interpolation via interp1() . Multiplication now works faster for Matlab version 2021b and newer. Updated all other classes to reflect the namechange to fluidcell . Class of iFluidCorrelator has changed name to CorrelationModule The class has been moved to the new folder \\modules , where future separate modules will be found. Zeroth single-particle eigenvalue no longer defaults to the XXZ-chain. Version 1.2.0 Added class DiffusionSolver for solving the GHD equation with a diffusion term. Updated class CollisionSolver to now take into account the two lowest transverse excited states. Added several methods to class LiebLinigerModel for fitting initial states. Version 1.1.0 Added class iFluidCorrelator for calculating dynamic Euler-scale two-point correlations. Added class LinearDiffusionSolver for solving the GHD propagation equation with linearized diffusion. Added class CollisionSolver for solving the GHD propagation equation with added collision integral. Only works for Lieb-Liniger model in dimensional crossover. Changed function calcEffectiveEnergy() to take source term as input rather than temperature. Arguments x , t and rapid is now for many functions in iFluidCore optional. If no variable is passed to function, the grids stored in the class will be used instead.","title":"Changelog"},{"location":"changelog/#version-21","text":"Changed the way optional inputs are parsed in the function calcCharges . To calculate the one-particle form factors, call calcCharges(..., 'calc_formfactors', true) . To obtain the individual charges and currents for each quasi-particle type, call calcCharges(..., 'sum_types', false) .","title":"Version 2.1"},{"location":"changelog/#version-20","text":"Class iFluidTensor has changed name to fluidcell to better reflect its physical meaning. The data structure now has a clearer and readable constructor. The data can now be referenced and assigned similar to regular Matlab arrays. Added support for trigonometric functions. Added support for 1D interpolation via interp1() . Multiplication now works faster for Matlab version 2021b and newer. Updated all other classes to reflect the namechange to fluidcell . Class of iFluidCorrelator has changed name to CorrelationModule The class has been moved to the new folder \\modules , where future separate modules will be found. Zeroth single-particle eigenvalue no longer defaults to the XXZ-chain.","title":"Version 2.0"},{"location":"changelog/#version-120","text":"Added class DiffusionSolver for solving the GHD equation with a diffusion term. Updated class CollisionSolver to now take into account the two lowest transverse excited states. Added several methods to class LiebLinigerModel for fitting initial states.","title":"Version 1.2.0"},{"location":"changelog/#version-110","text":"Added class iFluidCorrelator for calculating dynamic Euler-scale two-point correlations. Added class LinearDiffusionSolver for solving the GHD propagation equation with linearized diffusion. Added class CollisionSolver for solving the GHD propagation equation with added collision integral. Only works for Lieb-Liniger model in dimensional crossover. Changed function calcEffectiveEnergy() to take source term as input rather than temperature. Arguments x , t and rapid is now for many functions in iFluidCore optional. If no variable is passed to function, the grids stored in the class will be used instead.","title":"Version 1.1.0"},{"location":"correlations/","text":"Euler-scale dynamical correlation functions By combining GHD with the fluctuation-dissipation theorem, one can calculate exact Euler-scale dynamical two-point correlation function. In GHD, each fluid cell (point in space-time) is described by its own generalized Gibbs ensemble (GGE). Thus, all equal-time, space-separated connected correlation functions vanish. However, over time the propagation of quasi-particles causes quantities in separated fluid cells to become correlated in a non-trivial manner. Hence, dynamical correlations at the Euler scale can be viewed as initial delta-functions correlations, which over time ballistically spread and propagate throughout the system. Methods of CorrelationModule class The class CorrelationModule contains all the methods necessary for computing the correlation functions. Constructor obj = CorrelationModule(coreObj, Options) Construct an CorrelationModule for calculating Euler-scale correlations. Inputs: coreObj : CorrelationModule object specifying the model and problem at hand. Options : Struct of settings. Returns: obj : CorrelationModule object. Methods for calculating correlations [direct, indirect] = calc2PCorrelations(obj, theta_t, u_t, t_array, y_indices, VO1_t, VO2_0) Calculates the two-point correlation function , where x are all entries in x_grid specified in iFluidCore . The correlations split into a direct and an indirect part, where the full correlations is the sum of the two. Inputs: theta_t : Cell array of filling functions. First entry must be for time t=0 . u_t : Cell array of characteristic functions. First entry must be for time t=0 . t_array : Array of times corresponding to entries in theta_t and u_t . y_indices : Array of indices, such that x_grid(y_indices) produces the desired values of y . VO1_t : Cell array containing form factors of operator O1 at time t_array(2:end) . VO2_0 : Form factor of operator O2 at time t=0 . Returns: direct : Matrix containing the direct correlations. indirect : Matrix containing the indirect correlations. Examples In this example we calculate the dynamic density-current correlations of a bump release in the Lieb-Liniger model. The full example code can be found in the /Examples folder in the iFluid github repository . Setting up the problem and solving the dynamics First we set up the grids, couplings, etc. The correlations implemented in iFluid version v1.1.0 only cover evolution with homogeneous couplings, although the initial state can be inhomogeneous. N = 2^7; % number of rapidity gridpoints M = 2^8+1; % number of spatial gridpoints dt = 0.025; % length of timestep rmax = 7; % max rapidity xmax = 5; % max posistion tmax = 1; % max time rap_array = linspace(-rmax, rmax, N); % rapidity grid rap_w = rap_array(2) - rap_array(1); % rapidity quadrature weights x_array = linspace(-xmax, xmax, M); % position grid t_array = linspace(0, tmax, tmax/dt+1); % array of timesteps % couplings are chemical potential and interaction strength couplings = { @(t,x) 0 , @(t,x) 1 ; % couplings [] , [] ; % d/dt couplings [] , [] }; % d/dx couplings T = 0.5; % temperature Next, we solve the dynamics of the system. In order to calculate the correlations, we need the filling function and the position characteristic. %% Initialize state and solve dynamics % Initialize TBA for the Lieb-Liniger model TBA = LiebLinigerModel(x_array, rap_array, rap_w, couplings); % Intialize second order solver of the GHD equation Solver2 = SecondOrderSolver(TBA, []); % Set inital chemical potential and calculate thermal state coup_init = { @(t,x) 2 - 2*x.^2 , @(t,x) 1}; theta_init = TBA.calcThermalState(T, coup_init); % Propagate intial state according to the couplings [theta_t, u_t] = Solver2.propagateTheta(theta_init, t_array); Calculating correlations In order to calculate the correlations between the density and its associated current, , we need the one-particle form factor of the density and the current operator. Both are available via the calcCharges() method in the iFluidCore class simply by passing a flag to the method. The method returns the form factors as a cell array for each time in t_array . Thus, we need the first cell of the current form factors and all the remaining cells of the density form factors. % Initialize object for calculating correlations iCorr = iFluidCorrelator(TBA, []); % Calculate form factors of density and associated current calcFormFac = true; [q,j,Vq,Vj] = TBA.calcCharges( 0, theta_t, t_array, calcFormFac ); % Calculate correlations at y = x_array((1+M)/2) and all times in t_array [dir, indir]= iCorr.calc2PCorrelations( theta_t, u_t, t_array, (1+M)/2, Vq(2:end), Vj{1} ); Plot results Finally, we can plot the results of the calculation (direct above, indirect below). The direct and indirect correlations are plotted separately, as they are of very different scales. The direct correlations are the main contribution, and denote the correlations carried by quasi-particles with the inverse trajectories given by the characteristics. Meanwhile, the indirect correlations are due to disturbances of the trajectories due inhomogeneities in the initial state.","title":"Correlation functions"},{"location":"correlations/#euler-scale-dynamical-correlation-functions","text":"By combining GHD with the fluctuation-dissipation theorem, one can calculate exact Euler-scale dynamical two-point correlation function. In GHD, each fluid cell (point in space-time) is described by its own generalized Gibbs ensemble (GGE). Thus, all equal-time, space-separated connected correlation functions vanish. However, over time the propagation of quasi-particles causes quantities in separated fluid cells to become correlated in a non-trivial manner. Hence, dynamical correlations at the Euler scale can be viewed as initial delta-functions correlations, which over time ballistically spread and propagate throughout the system.","title":"Euler-scale dynamical correlation functions"},{"location":"correlations/#methods-of-correlationmodule-class","text":"The class CorrelationModule contains all the methods necessary for computing the correlation functions.","title":"Methods of CorrelationModule class"},{"location":"correlations/#constructor","text":"","title":"Constructor"},{"location":"correlations/#obj-correlationmodulecoreobj-options","text":"Construct an CorrelationModule for calculating Euler-scale correlations. Inputs: coreObj : CorrelationModule object specifying the model and problem at hand. Options : Struct of settings. Returns: obj : CorrelationModule object.","title":"obj = CorrelationModule(coreObj, Options)"},{"location":"correlations/#methods-for-calculating-correlations","text":"","title":"Methods for calculating correlations"},{"location":"correlations/#direct-indirect-calc2pcorrelationsobj-theta_t-u_t-t_array-y_indices-vo1_t-vo2_0","text":"Calculates the two-point correlation function , where x are all entries in x_grid specified in iFluidCore . The correlations split into a direct and an indirect part, where the full correlations is the sum of the two. Inputs: theta_t : Cell array of filling functions. First entry must be for time t=0 . u_t : Cell array of characteristic functions. First entry must be for time t=0 . t_array : Array of times corresponding to entries in theta_t and u_t . y_indices : Array of indices, such that x_grid(y_indices) produces the desired values of y . VO1_t : Cell array containing form factors of operator O1 at time t_array(2:end) . VO2_0 : Form factor of operator O2 at time t=0 . Returns: direct : Matrix containing the direct correlations. indirect : Matrix containing the indirect correlations.","title":"[direct, indirect] = calc2PCorrelations(obj, theta_t, u_t, t_array, y_indices, VO1_t, VO2_0)"},{"location":"correlations/#examples","text":"In this example we calculate the dynamic density-current correlations of a bump release in the Lieb-Liniger model. The full example code can be found in the /Examples folder in the iFluid github repository .","title":"Examples"},{"location":"correlations/#setting-up-the-problem-and-solving-the-dynamics","text":"First we set up the grids, couplings, etc. The correlations implemented in iFluid version v1.1.0 only cover evolution with homogeneous couplings, although the initial state can be inhomogeneous. N = 2^7; % number of rapidity gridpoints M = 2^8+1; % number of spatial gridpoints dt = 0.025; % length of timestep rmax = 7; % max rapidity xmax = 5; % max posistion tmax = 1; % max time rap_array = linspace(-rmax, rmax, N); % rapidity grid rap_w = rap_array(2) - rap_array(1); % rapidity quadrature weights x_array = linspace(-xmax, xmax, M); % position grid t_array = linspace(0, tmax, tmax/dt+1); % array of timesteps % couplings are chemical potential and interaction strength couplings = { @(t,x) 0 , @(t,x) 1 ; % couplings [] , [] ; % d/dt couplings [] , [] }; % d/dx couplings T = 0.5; % temperature Next, we solve the dynamics of the system. In order to calculate the correlations, we need the filling function and the position characteristic. %% Initialize state and solve dynamics % Initialize TBA for the Lieb-Liniger model TBA = LiebLinigerModel(x_array, rap_array, rap_w, couplings); % Intialize second order solver of the GHD equation Solver2 = SecondOrderSolver(TBA, []); % Set inital chemical potential and calculate thermal state coup_init = { @(t,x) 2 - 2*x.^2 , @(t,x) 1}; theta_init = TBA.calcThermalState(T, coup_init); % Propagate intial state according to the couplings [theta_t, u_t] = Solver2.propagateTheta(theta_init, t_array);","title":"Setting up the problem and solving the dynamics"},{"location":"correlations/#calculating-correlations","text":"In order to calculate the correlations between the density and its associated current, , we need the one-particle form factor of the density and the current operator. Both are available via the calcCharges() method in the iFluidCore class simply by passing a flag to the method. The method returns the form factors as a cell array for each time in t_array . Thus, we need the first cell of the current form factors and all the remaining cells of the density form factors. % Initialize object for calculating correlations iCorr = iFluidCorrelator(TBA, []); % Calculate form factors of density and associated current calcFormFac = true; [q,j,Vq,Vj] = TBA.calcCharges( 0, theta_t, t_array, calcFormFac ); % Calculate correlations at y = x_array((1+M)/2) and all times in t_array [dir, indir]= iCorr.calc2PCorrelations( theta_t, u_t, t_array, (1+M)/2, Vq(2:end), Vj{1} );","title":"Calculating correlations"},{"location":"correlations/#plot-results","text":"Finally, we can plot the results of the calculation (direct above, indirect below). The direct and indirect correlations are plotted separately, as they are of very different scales. The direct correlations are the main contribution, and denote the correlations carried by quasi-particles with the inverse trajectories given by the characteristics. Meanwhile, the indirect correlations are due to disturbances of the trajectories due inhomogeneities in the initial state.","title":"Plot results"},{"location":"iFluidCore/","text":"iFluidCore This class implements the general TBA equations. Following the hydrodynamical principle, the system is always in a quasi-stationary state, whereby all the methods of the class can be applied at any time for any given filling function. Note, the iFluidCore class is abstract and must be extended by classes encoding an actual integrable model. Click here to see how to implement your own model. Constructor obj = iFluidCore(x_grid, rapid_grid, rapid_w, couplings, Ntypes, Options) Construct an iFluidCore object containing all the information and methods of a TBA of a given model. Inputs: x_grid : Vector of M gridpoints in position space. rapid_grid : Vector of N gridpoints in rapidity space. rapid_w : Vector of N rapidity quadrature weights. couplings : Cell array of couplings and their time and space derivatives. Ntypes : Number of quasiparticle types in the TBA of the model. Options : Struct of settings. Returns: obj : iFluidCore object. Abstract (model specific) methods ebare = getBareEnergy(obj, t, x, rapid, type) Calculate the one-particle energy. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: ebare : One-particle energy. pbare = getBareMomentum(obj, t, x, rapid, type) Calculate the one-particle momentum. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: pbare : One-particle momentum. de = getEnergyRapidDeriv(obj, t, x, rapid, type) Calculate the derivative of the one-particle energy w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: de : Derivative of one-particle energy. dp = getMomentumRapidDeriv(obj, t, x, rapid, type) Calculate the derivative of the one-particle momentum w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: dp : Derivative of one-particle momentum. dT = getScatteringRapidDeriv(obj, t, x, rapid1, rapid2, type1, type2) Calculate the derivative of the two-body scattering phase w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid1 : Scalar or vector indicating the (main) rapidity. rapid2 : Scalar or vector indicating the (convilution) rapidity. type1 : Scalar or vector indicating the (main) type index of the quasiparticles. type2 : Scalar or vector indicating the (convolution) type index of the quasiparticles. Returns: dT : Derivative of the two-body scattering phase. Must be an fluidcell . de = getEnergyCouplingDeriv(obj, coupIdx, t, x, rapid, type) Calculate the derivative of the one-particle energy w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: de : Derivative of one-particle energy. dp = getMomentumCouplingDeriv(obj, coupIdx, t, x, rapid, type) Calculate the derivative of the one-particle momentum w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: dp : Derivative of one-particle momentum. dT = getScatteringCouplingDeriv(obj, coupIdx, t, x, rapid1, rapid2, type1, type2) Calculate the derivative of the two-body scattering phase w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid1 : Scalar or vector indicating the (main) rapidity. rapid2 : Scalar or vector indicating the (convilution) rapidity. type1 : Scalar or vector indicating the (main) type index of the quasiparticles. type2 : Scalar or vector indicating the (convolution) type index of the quasiparticles. Returns: dT : Derivative of the two-body scattering phase. Must be an fluidcell . Accessor methods setCouplings(obj, couplings) Set the couplings of the model. Inputs: couplings : Cell array of couplings and their time and space derivatives. couplings = getCouplings(obj) Get the couplings of the model. Returns: couplings : Cell array of couplings and their time and space derivatives. [x_grid, rapid_grid, type_grid, rapid_w] = getGrids(obj) Get all grids of the system. Returns: x_grid : Vector of M gridpoints in position space. rapid_grid : Vector of N gridpoints in rapidity space. rapid_w : Vector of N rapidity quadrature weights. type_grid : Vector from 1 to Ntypes . TBA methods Q_dr = applyDressing(obj, Q, theta, t) Dress the quantity Q , threby taking into account the collective iteractions of the quasiparticles. Inputs: Q : Quantity to be dressed. Must be an fluidcell . theta : Filling function at time t . Must be an fluidcell . t : Scalar indicating the time, corresponding to theta . Returns: Q_dr : Dressed quantity as fluidcell . h_i = getOneParticleEV(obj, charIdx, t, x, rapid) Returns the one-particle eigenvalue of the i'th conserved charge. By default the 0th charge is the number operator, the 1st charge is the momentum, and the 2nd charge is the Hamiltonian. Inputs: charIdx : Scalar indicating which charge is considered. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. Returns: h_i : Matrix containing the eigenvalues. [rho_t, rhoS_t] = transform2rho(obj, theta_t, t_array) Constructs the root density and the density of states from the filling function. Inputs: theta_t : Cell array of (or single) filling functions as fluidcell . t_array : Vector of times corresponding to the fillings in theta_t . Returns: rho_t : Cell array of (or single) root densities as fluidcell . rhoS_t : Cell array of (or single) density of states as fluidcell . [theta_t, rhoS_t] = transform2theta(obj, rho_t, t_array) Constructs the filling function and the density of states from the root density. Inputs: rho_t : Cell array of (or single) root densities as fluidcell . t_array : Vector of times corresponding to the root densities in rho_t . Returns: theta_t : Cell array of (or single) filling functions as fluidcell . rhoS_t : Cell array of (or single) density of states as fluidcell . [q, j, Vq, Vj] = calcCharges(obj, c_idx, theta_t, t_array, varargin) Calculate the expectation values of the i'th charge densities and associated currents. Inputs: c_idx : Scalar or vector of indices indicating which charges to consider. theta_t : Cell array of (or single) filling functions as fluidcell . t_array : Vector of times corresponding to the fillings in theta_t . varargin : Optional arguments, passed as calcCharges(..., 'argument_name', value) calc_formfactors : (default=false) if true, calculate Vq and Vj . sum_types : (default=true) if true, sum the contributions of the individual quasi-particle types when computing the charges. Returns: q : Matrix of charge density expectation values for times in t_array . j : Matrix of charge current expectation values for times in t_array . Vq : Cell array of one-particle density form factors for times in t_array . Vj : Cell array of one-particle current form factors for times in t_array . [theta, e_eff] = calcThermalState(obj, T, TBA_couplings) Calculates a thermal state of the model specified by the couplings and temperature. Inputs: T : Temperature. Can be either a scalar (homogeneous) or an anonymous function of x (inhomogeneous). TBA_couplings : (Optional) Cell array of couplings. If none specified, the couplings of the iFluidCore object are used instead. Returns: theta : Filling function of thermal state as fluidcell . e_eff : Pseudo-energy of thermal state as fluidcell . [v_eff, a_eff] = calcEffectiveVelocities(obj, theta, t, x, rapid, type) Calculate the effective velocity and acceleration of the quasiparticles given the current state of the system. Inputs: theta : Filling function at time t . t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: v_eff : Effective velocity as fluidcell . a_eff : Effective acceleration as fluidcell . e_eff = calcEffectiveEnergy(obj, w, t, x) Calculate the pseudo-energy of the system. Inputs: w : Source term. . t : Scalar indicating the time. x : Scalar or vector indicating the position. Returns: e_eff : Peuso-energy as fluidcell . Methods dependent on quasiparticle statisitcs f = getStatFactor(obj, theta) Returns the statistical factor based the statistics followed by the quasiparticles of the model. Inputs: theta : Filling function as fluidcell . Returns: f : Statistical factor as fluidcell . F = getFreeEnergy(obj, e_eff) Returns the free energy function of the model based on the quasiparticle statistics. Inputs: e_eff : Pseudo-energy of the state as fluidcell . Returns: F : Free energy function as fluidcell . theta = calcFillingFraction(obj, e_eff) Calculates the filling function of a thermal state based on the quasiparticle statistics. Inputs: e_eff : Pseudo-energy of the state as fluidcell . Returns: theta : Filling function as fluidcell . Options The iFluidCore class takes an Options struct as argument in its constructor. The Options struct can hold the following (case sensitive!) parameters, which are transferred to the iFluidCore object upon construction. The possible options are: homoEvol (default false ): Indicates if all couplings are homogeneous. If true, a_eff will not be calculated. tolerance (default 1e-6 ): Tolerance for iterative solution for pseudo-energy. maxcount (default 100 ): Max nnumber of iterations for finding pseudo-energy.","title":"iFluidCore"},{"location":"iFluidCore/#ifluidcore","text":"This class implements the general TBA equations. Following the hydrodynamical principle, the system is always in a quasi-stationary state, whereby all the methods of the class can be applied at any time for any given filling function. Note, the iFluidCore class is abstract and must be extended by classes encoding an actual integrable model. Click here to see how to implement your own model.","title":"iFluidCore"},{"location":"iFluidCore/#constructor","text":"","title":"Constructor"},{"location":"iFluidCore/#obj-ifluidcorex_grid-rapid_grid-rapid_w-couplings-ntypes-options","text":"Construct an iFluidCore object containing all the information and methods of a TBA of a given model. Inputs: x_grid : Vector of M gridpoints in position space. rapid_grid : Vector of N gridpoints in rapidity space. rapid_w : Vector of N rapidity quadrature weights. couplings : Cell array of couplings and their time and space derivatives. Ntypes : Number of quasiparticle types in the TBA of the model. Options : Struct of settings. Returns: obj : iFluidCore object.","title":"obj = iFluidCore(x_grid, rapid_grid, rapid_w, couplings, Ntypes, Options)"},{"location":"iFluidCore/#abstract-model-specific-methods","text":"","title":"Abstract (model specific) methods"},{"location":"iFluidCore/#ebare-getbareenergyobj-t-x-rapid-type","text":"Calculate the one-particle energy. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: ebare : One-particle energy.","title":"ebare = getBareEnergy(obj, t, x, rapid, type)"},{"location":"iFluidCore/#pbare-getbaremomentumobj-t-x-rapid-type","text":"Calculate the one-particle momentum. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: pbare : One-particle momentum.","title":"pbare = getBareMomentum(obj, t, x, rapid, type)"},{"location":"iFluidCore/#de-getenergyrapidderivobj-t-x-rapid-type","text":"Calculate the derivative of the one-particle energy w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: de : Derivative of one-particle energy.","title":"de = getEnergyRapidDeriv(obj, t, x, rapid, type)"},{"location":"iFluidCore/#dp-getmomentumrapidderivobj-t-x-rapid-type","text":"Calculate the derivative of the one-particle momentum w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: dp : Derivative of one-particle momentum.","title":"dp = getMomentumRapidDeriv(obj, t, x, rapid, type)"},{"location":"iFluidCore/#dt-getscatteringrapidderivobj-t-x-rapid1-rapid2-type1-type2","text":"Calculate the derivative of the two-body scattering phase w.r.t. the rapidity. Inputs: t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid1 : Scalar or vector indicating the (main) rapidity. rapid2 : Scalar or vector indicating the (convilution) rapidity. type1 : Scalar or vector indicating the (main) type index of the quasiparticles. type2 : Scalar or vector indicating the (convolution) type index of the quasiparticles. Returns: dT : Derivative of the two-body scattering phase. Must be an fluidcell .","title":"dT = getScatteringRapidDeriv(obj, t, x, rapid1, rapid2, type1, type2)"},{"location":"iFluidCore/#de-getenergycouplingderivobj-coupidx-t-x-rapid-type","text":"Calculate the derivative of the one-particle energy w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: de : Derivative of one-particle energy.","title":"de = getEnergyCouplingDeriv(obj, coupIdx, t, x, rapid, type)"},{"location":"iFluidCore/#dp-getmomentumcouplingderivobj-coupidx-t-x-rapid-type","text":"Calculate the derivative of the one-particle momentum w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: dp : Derivative of one-particle momentum.","title":"dp = getMomentumCouplingDeriv(obj, coupIdx, t, x, rapid, type)"},{"location":"iFluidCore/#dt-getscatteringcouplingderivobj-coupidx-t-x-rapid1-rapid2-type1-type2","text":"Calculate the derivative of the two-body scattering phase w.r.t. the couplings. Inputs: coupIdx : Index indicating the coupling in question. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid1 : Scalar or vector indicating the (main) rapidity. rapid2 : Scalar or vector indicating the (convilution) rapidity. type1 : Scalar or vector indicating the (main) type index of the quasiparticles. type2 : Scalar or vector indicating the (convolution) type index of the quasiparticles. Returns: dT : Derivative of the two-body scattering phase. Must be an fluidcell .","title":"dT = getScatteringCouplingDeriv(obj, coupIdx, t, x, rapid1, rapid2, type1, type2)"},{"location":"iFluidCore/#accessor-methods","text":"","title":"Accessor methods"},{"location":"iFluidCore/#setcouplingsobj-couplings","text":"Set the couplings of the model. Inputs: couplings : Cell array of couplings and their time and space derivatives.","title":"setCouplings(obj, couplings)"},{"location":"iFluidCore/#couplings-getcouplingsobj","text":"Get the couplings of the model. Returns: couplings : Cell array of couplings and their time and space derivatives.","title":"couplings = getCouplings(obj)"},{"location":"iFluidCore/#x_grid-rapid_grid-type_grid-rapid_w-getgridsobj","text":"Get all grids of the system. Returns: x_grid : Vector of M gridpoints in position space. rapid_grid : Vector of N gridpoints in rapidity space. rapid_w : Vector of N rapidity quadrature weights. type_grid : Vector from 1 to Ntypes .","title":"[x_grid, rapid_grid, type_grid, rapid_w] = getGrids(obj)"},{"location":"iFluidCore/#tba-methods","text":"","title":"TBA methods"},{"location":"iFluidCore/#q_dr-applydressingobj-q-theta-t","text":"Dress the quantity Q , threby taking into account the collective iteractions of the quasiparticles. Inputs: Q : Quantity to be dressed. Must be an fluidcell . theta : Filling function at time t . Must be an fluidcell . t : Scalar indicating the time, corresponding to theta . Returns: Q_dr : Dressed quantity as fluidcell .","title":"Q_dr = applyDressing(obj, Q, theta, t)"},{"location":"iFluidCore/#h_i-getoneparticleevobj-charidx-t-x-rapid","text":"Returns the one-particle eigenvalue of the i'th conserved charge. By default the 0th charge is the number operator, the 1st charge is the momentum, and the 2nd charge is the Hamiltonian. Inputs: charIdx : Scalar indicating which charge is considered. t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. Returns: h_i : Matrix containing the eigenvalues.","title":"h_i = getOneParticleEV(obj, charIdx, t, x, rapid)"},{"location":"iFluidCore/#rho_t-rhos_t-transform2rhoobj-theta_t-t_array","text":"Constructs the root density and the density of states from the filling function. Inputs: theta_t : Cell array of (or single) filling functions as fluidcell . t_array : Vector of times corresponding to the fillings in theta_t . Returns: rho_t : Cell array of (or single) root densities as fluidcell . rhoS_t : Cell array of (or single) density of states as fluidcell .","title":"[rho_t, rhoS_t] = transform2rho(obj, theta_t, t_array)"},{"location":"iFluidCore/#theta_t-rhos_t-transform2thetaobj-rho_t-t_array","text":"Constructs the filling function and the density of states from the root density. Inputs: rho_t : Cell array of (or single) root densities as fluidcell . t_array : Vector of times corresponding to the root densities in rho_t . Returns: theta_t : Cell array of (or single) filling functions as fluidcell . rhoS_t : Cell array of (or single) density of states as fluidcell .","title":"[theta_t, rhoS_t] = transform2theta(obj, rho_t, t_array)"},{"location":"iFluidCore/#q-j-vq-vj-calcchargesobj-c_idx-theta_t-t_array-varargin","text":"Calculate the expectation values of the i'th charge densities and associated currents. Inputs: c_idx : Scalar or vector of indices indicating which charges to consider. theta_t : Cell array of (or single) filling functions as fluidcell . t_array : Vector of times corresponding to the fillings in theta_t . varargin : Optional arguments, passed as calcCharges(..., 'argument_name', value) calc_formfactors : (default=false) if true, calculate Vq and Vj . sum_types : (default=true) if true, sum the contributions of the individual quasi-particle types when computing the charges. Returns: q : Matrix of charge density expectation values for times in t_array . j : Matrix of charge current expectation values for times in t_array . Vq : Cell array of one-particle density form factors for times in t_array . Vj : Cell array of one-particle current form factors for times in t_array .","title":"[q, j, Vq, Vj] = calcCharges(obj, c_idx, theta_t, t_array, varargin)"},{"location":"iFluidCore/#theta-e_eff-calcthermalstateobj-t-tba_couplings","text":"Calculates a thermal state of the model specified by the couplings and temperature. Inputs: T : Temperature. Can be either a scalar (homogeneous) or an anonymous function of x (inhomogeneous). TBA_couplings : (Optional) Cell array of couplings. If none specified, the couplings of the iFluidCore object are used instead. Returns: theta : Filling function of thermal state as fluidcell . e_eff : Pseudo-energy of thermal state as fluidcell .","title":"[theta, e_eff] = calcThermalState(obj, T, TBA_couplings)"},{"location":"iFluidCore/#v_eff-a_eff-calceffectivevelocitiesobj-theta-t-x-rapid-type","text":"Calculate the effective velocity and acceleration of the quasiparticles given the current state of the system. Inputs: theta : Filling function at time t . t : Scalar indicating the time. x : Scalar or vector indicating the position. rapid : Scalar or vector indicating the rapidity. type : Scalar or vector indicating the type index of the quasiparticles. Returns: v_eff : Effective velocity as fluidcell . a_eff : Effective acceleration as fluidcell .","title":"[v_eff, a_eff] = calcEffectiveVelocities(obj, theta, t, x, rapid, type)"},{"location":"iFluidCore/#e_eff-calceffectiveenergyobj-w-t-x","text":"Calculate the pseudo-energy of the system. Inputs: w : Source term. . t : Scalar indicating the time. x : Scalar or vector indicating the position. Returns: e_eff : Peuso-energy as fluidcell .","title":"e_eff = calcEffectiveEnergy(obj, w, t, x)"},{"location":"iFluidCore/#methods-dependent-on-quasiparticle-statisitcs","text":"","title":"Methods dependent on quasiparticle statisitcs"},{"location":"iFluidCore/#f-getstatfactorobj-theta","text":"Returns the statistical factor based the statistics followed by the quasiparticles of the model. Inputs: theta : Filling function as fluidcell . Returns: f : Statistical factor as fluidcell .","title":"f = getStatFactor(obj, theta)"},{"location":"iFluidCore/#f-getfreeenergyobj-e_eff","text":"Returns the free energy function of the model based on the quasiparticle statistics. Inputs: e_eff : Pseudo-energy of the state as fluidcell . Returns: F : Free energy function as fluidcell .","title":"F = getFreeEnergy(obj, e_eff)"},{"location":"iFluidCore/#theta-calcfillingfractionobj-e_eff","text":"Calculates the filling function of a thermal state based on the quasiparticle statistics. Inputs: e_eff : Pseudo-energy of the state as fluidcell . Returns: theta : Filling function as fluidcell .","title":"theta = calcFillingFraction(obj, e_eff)"},{"location":"iFluidCore/#options","text":"The iFluidCore class takes an Options struct as argument in its constructor. The Options struct can hold the following (case sensitive!) parameters, which are transferred to the iFluidCore object upon construction. The possible options are: homoEvol (default false ): Indicates if all couplings are homogeneous. If true, a_eff will not be calculated. tolerance (default 1e-6 ): Tolerance for iterative solution for pseudo-energy. maxcount (default 100 ): Max nnumber of iterations for finding pseudo-energy.","title":"Options"},{"location":"iFluidSolver/","text":"iFluidSolver The purpose of the iFluidSolver class is to propagate the filling function in time following the hydrodynamic equation This is achieved by approximating the propagation for a single time-step dt . Note, the iFluidSolver class is abstract and must be extended by classes encoding algorithms for performing the time-step. Click here to see how to implement your own algorithm. Constructor obj = iFluidSolver(coreObj, Options) Construct an iFluidSolver object for solving the hydrodynamical propagation equation. Inputs: coreObj : iFluidCore object specifying the model and problem at hand. Options : Struct of settings. Returns: obj : iFluidSolver object. Abstract (algorithm specific) methods [theta, u, w] = initialize(obj, theta_init, u_init, w_init, t_array ) Calculates and stores all the required quantities used by the algorithm implemented in step() . Inputs: theta_init : Initial filling function (t = 0), as fluidcell . u_init : Initial position characteristic (t = 0), as fluidcell . w_init : Initial rapidity characteristic (t = 0), as fluidcell . t_array : Vector of timesteps. Returns: theta : Filling passed to first call of step() . Typically equal to theta_init . u : Position characteristic passed to first call of step() . Typically equal to u_init . w : Rapidity characteristic passed to first call of step() . Typically equal to w_init . [theta_next, u_next, w_next] = step(obj, theta_prev, u_prev, w_prev, t, dt) Propagates the filling function one timestep dt . Inputs: theta_prev : Filling function at time t , as fluidcell . u_prev : Position characteristic at time t , as fluidcell . w_prev : Rapidity characteristic at time t , as fluidcell . t : Time at the start of the step. dt : Length of step. Returns: theta_next : Filling function at time t + dt , as fluidcell . u_next : Position characteristic at time t + dt , as fluidcell . w_next : Rapidity characteristic at time t + dt , as fluidcell . Time propagation methods [theta_t, u_t, w_t] = propagateTheta(obj, theta_init, t_array) Propagates the filling function according to the hydrodynamical equation using the user-implemented step() method. Inputs: theta_init : Initial filling function (t = 0), as fluidcell . t_array : Vector of starting times of each step. Returns: theta_t : Cell array of filling functions for each time in t_array . u_t : Cell array of position characteristics for each time in t_array . w_t : Cell array of rapidity characteristics for each time in t_array . Additional methods [theta_next, u_next, w_next] = performFirstOrderStep(obj, theta_prev, u_prev, w_prev, t, dt) Propagates the filling function one timestep dt using a first-order approximation. This method is helpful for calculating the required quantities for more sophisticated step() algorithms. Inputs: theta_prev : Filling function at time t , as fluidcell . u_prev : Position characteristic at time t , as fluidcell . w_prev : Rapidity characteristic at time t , as fluidcell . t : Time at the start of the step. dt : Length of step. Returns: theta_next : Filling function at time t + dt , as fluidcell . u_next : Position characteristic at time t + dt , as fluidcell . w_next : Rapidity characteristic at time t + dt , as fluidcell . tensor_int = interpPhaseSpace(obj, tensor_grid, rapid_int, x_int, extrapFlag) Interpolates a quantity defined on the grids x_grid and rapid_grid from the stored iFluidCore object. Inputs: tensor_grid : Quantity to interpolate. Must be fluidcell . rapid_int : Matrix of rapidities to interpolate to. x_int : Matrix of positions to interpolate to. extrapFlag : Flag for extrapolation. If true , extrapolation is allowed. If false , all extrapolated values are 0. Returns: tensor_int : tensor_grid interpolate to rapid_int and x_int . Options The iFluidSolver class takes an Options struct as argument in its constructor. The Options struct can hold the following (case sensitive!) parameters, which are transferred to the iFluidSolver object upon construction. The possible options are: extrapFlag (default false ): Indicates if extrapolation is allowed. periodRapid (default false ): Indicates if rapidity is periodic.","title":"iFluidSolver"},{"location":"iFluidSolver/#ifluidsolver","text":"The purpose of the iFluidSolver class is to propagate the filling function in time following the hydrodynamic equation This is achieved by approximating the propagation for a single time-step dt . Note, the iFluidSolver class is abstract and must be extended by classes encoding algorithms for performing the time-step. Click here to see how to implement your own algorithm.","title":"iFluidSolver"},{"location":"iFluidSolver/#constructor","text":"","title":"Constructor"},{"location":"iFluidSolver/#obj-ifluidsolvercoreobj-options","text":"Construct an iFluidSolver object for solving the hydrodynamical propagation equation. Inputs: coreObj : iFluidCore object specifying the model and problem at hand. Options : Struct of settings. Returns: obj : iFluidSolver object.","title":"obj = iFluidSolver(coreObj, Options)"},{"location":"iFluidSolver/#abstract-algorithm-specific-methods","text":"","title":"Abstract (algorithm specific) methods"},{"location":"iFluidSolver/#theta-u-w-initializeobj-theta_init-u_init-w_init-t_array","text":"Calculates and stores all the required quantities used by the algorithm implemented in step() . Inputs: theta_init : Initial filling function (t = 0), as fluidcell . u_init : Initial position characteristic (t = 0), as fluidcell . w_init : Initial rapidity characteristic (t = 0), as fluidcell . t_array : Vector of timesteps. Returns: theta : Filling passed to first call of step() . Typically equal to theta_init . u : Position characteristic passed to first call of step() . Typically equal to u_init . w : Rapidity characteristic passed to first call of step() . Typically equal to w_init .","title":"[theta, u, w] = initialize(obj, theta_init, u_init, w_init, t_array )"},{"location":"iFluidSolver/#theta_next-u_next-w_next-stepobj-theta_prev-u_prev-w_prev-t-dt","text":"Propagates the filling function one timestep dt . Inputs: theta_prev : Filling function at time t , as fluidcell . u_prev : Position characteristic at time t , as fluidcell . w_prev : Rapidity characteristic at time t , as fluidcell . t : Time at the start of the step. dt : Length of step. Returns: theta_next : Filling function at time t + dt , as fluidcell . u_next : Position characteristic at time t + dt , as fluidcell . w_next : Rapidity characteristic at time t + dt , as fluidcell .","title":"[theta_next, u_next, w_next] = step(obj, theta_prev, u_prev, w_prev, t, dt)"},{"location":"iFluidSolver/#time-propagation-methods","text":"","title":"Time propagation methods"},{"location":"iFluidSolver/#theta_t-u_t-w_t-propagatethetaobj-theta_init-t_array","text":"Propagates the filling function according to the hydrodynamical equation using the user-implemented step() method. Inputs: theta_init : Initial filling function (t = 0), as fluidcell . t_array : Vector of starting times of each step. Returns: theta_t : Cell array of filling functions for each time in t_array . u_t : Cell array of position characteristics for each time in t_array . w_t : Cell array of rapidity characteristics for each time in t_array .","title":"[theta_t, u_t, w_t] = propagateTheta(obj, theta_init, t_array)"},{"location":"iFluidSolver/#additional-methods","text":"","title":"Additional methods"},{"location":"iFluidSolver/#theta_next-u_next-w_next-performfirstorderstepobj-theta_prev-u_prev-w_prev-t-dt","text":"Propagates the filling function one timestep dt using a first-order approximation. This method is helpful for calculating the required quantities for more sophisticated step() algorithms. Inputs: theta_prev : Filling function at time t , as fluidcell . u_prev : Position characteristic at time t , as fluidcell . w_prev : Rapidity characteristic at time t , as fluidcell . t : Time at the start of the step. dt : Length of step. Returns: theta_next : Filling function at time t + dt , as fluidcell . u_next : Position characteristic at time t + dt , as fluidcell . w_next : Rapidity characteristic at time t + dt , as fluidcell .","title":"[theta_next, u_next, w_next] = performFirstOrderStep(obj, theta_prev, u_prev, w_prev, t, dt)"},{"location":"iFluidSolver/#tensor_int-interpphasespaceobj-tensor_grid-rapid_int-x_int-extrapflag","text":"Interpolates a quantity defined on the grids x_grid and rapid_grid from the stored iFluidCore object. Inputs: tensor_grid : Quantity to interpolate. Must be fluidcell . rapid_int : Matrix of rapidities to interpolate to. x_int : Matrix of positions to interpolate to. extrapFlag : Flag for extrapolation. If true , extrapolation is allowed. If false , all extrapolated values are 0. Returns: tensor_int : tensor_grid interpolate to rapid_int and x_int .","title":"tensor_int = interpPhaseSpace(obj, tensor_grid, rapid_int, x_int, extrapFlag)"},{"location":"iFluidSolver/#options","text":"The iFluidSolver class takes an Options struct as argument in its constructor. The Options struct can hold the following (case sensitive!) parameters, which are transferred to the iFluidSolver object upon construction. The possible options are: extrapFlag (default false ): Indicates if extrapolation is allowed. periodRapid (default false ): Indicates if rapidity is periodic.","title":"Options"},{"location":"iFluidTensor/","text":"fluidcell Quantities like the root densities of TBAs are functions of position and rapidity. Additionally, some TBAs contain multiple root densitites, each describing a different type of quasiparticle. Thus, the numerical representation of the root density can be achieved with a rank-3 tensor. Meanwhile, quantites like the two-body scattering phase encodes the interaction between two quasiparticles of (potentially) different type and rapidity. Thus, an extra type and rapidity arguement are needed resulting in a rank-5 tensor representation. Consider one of the most central operations of GHD calculations, namely the dressing of some quantity, h . This implies solving the set of linear equations: We won't be going into specifics regarding the quantities of the equation, however, the subscripts mark the rapidity indices, while the superscripts mark the quasiparticle type indices. The calculation requires contracting over two indices - similar to a matrix multiplication, which is just the contraction over a single index, The fluidcell class wraps around a standard Matlab 5-dimensional matrix and generalizes many of the standard 2-dimensional methods (such as matrix multiplication) to 4D. Thus, the multiplication above can be computed in iFluid via h = U*h_dr or solving the equation via h_dr = U\\h . To achieve this, the fluidcell class enforces a strict convention for indices, namely Main rapidity index. Position index. Main type index. Secondary rapidity index. Secondary type index. The purpose of the fluidcell is to perform multi-index contractions using the standard Matlab notation, which is achieved by overloading the mathematical operators + - ./ * .* \\ .^ . The indices of the fluidcell can be accessed using the standard Matlab referencing for arrays. Similarly, the index labels (name of indices) can be used for referencing as well. A = B(:,:,3) % returns the 3rd type index of B B(:,:,3) = A % sets the 3rd type index of B equal to A A = B('type',3) % returns the 3rd type index of B B('type',3) = A % sets the 3rd type index of B equal to A Constructor An fluidcell object can be initialized using a MAtlab ND-array, which the fluidcell will then wrap around. obj = fluidcell(A) Construct an fluidcell object using the ND-array input A as datastructure. Inputs: A : Standard Matlab ND-array up to 5 dimensions. Returns: obj : fluidcell object. obj = fluidcell.zeros(d1, d2, ... , dN ) or obj = fluidcell.zeros( [d1, d2, ... , dN] ) Construct an fluidcell object of zeros with indices of specified sizes (up to N = 5 indices). Inputs: d1, d2, ... , dN : Integers indicating size of the n 'th index. Returns: obj : fluidcell object. obj = fluidcell.ones(d1, d2, ... , dN ) or obj = fluidcell.ones( [d1, d2, ... , dN] ) Construct an fluidcell object of ones with indices of specified sizes (up to N = 5 indices). Inputs: d1, d2, ... , dN : Integers indicating size of the n 'th index. Returns: obj : fluidcell object. obj = fluidcell.eye( d_rapid, d_type ) Construct a \"square\" fluidcell object with ones at entries with matching rapidity and type indices. Inputs: d_rapid : Integer indicating size of the main and secondary rapidity index. d_type : Integer indicating size of the main and secondary type index. Returns: obj : fluidcell object. Accessor methods S = size(obj, idx) Returns size of entire tensor or one of its indices. Inputs: idx : (optional) Index in question. Returns: S : Sizes of all or specified index. out = double(obj) Returns tensor as standard Matlab matrix of doubles. Returns: out : Underlying matrix. Index manipulation methods out = flatten(obj) Returns a 3-dimensional matrix. The first index is the main rapidity index merged with the main type index. The second index is the secondary rapidity index merged with the secondary type index. The third index is the spatial index. Returns: out : Flattened tensor. out = unflatten(obj) Undoes the flatten() transformation. Returns: out : Un-flattened tensor. out = transpose(obj) / out = t(obj) Returns tensor with both the two rapidity and the two type indices permuted. Returns: out : Transposed tensor. Mathematical operators The fluidcell class overloads the elementwise mathematically operations + - ./ .* .^ along with abs() log() exp() Below are the overloaded methods, which have a different function than their Matlab counterpart. C = mtimes(A, B) / C = A*B Performs the two-index contraction Inputs: A : Matrix or tensor with dimensions ( Ra, Xa, Ta, N, L ) , with position index length, Xa , equal to 1 or M . B : Matrix or tensor with dimensions ( N, Xb, L, Rb, Tb ) , with position index length, Xb , equal to 1 or M . Returns: C : Matrix or tensor with dimensions ( Ra, max(Xa, Xb), Ta, Rb, Tb ) . x = mldivide(A, B) / x = A\\B Solves the system of linear equations Inputs: A : Matrix or tensor with dimensions ( N, Xa, L, Ra, Ta ) , with position index length, Xa , equal to 1 or M . B : Matrix or tensor with dimensions ( N, Xb, L, Rb, Tb ) , with position index length, Xb , equal to 1 or M . Returns: x : Matrix or tensor with dimensions ( Ra, max(Xa, Xb), Ta, Rb, Tb ) . B = inv(A) Returns the solution to the equations Inputs: A : Tensor with both rapidity indices and both type indices of equal length. Returns: B : \"Inverse\" of A . out = sum(obj, idx, t_str) Returns the tensor summed over the given index. Inputs: idx : Integer, or vector of integers, indicating the index in quation. t_str : (optional) String indicating output type: 'd' / 'double' : Returns standard Matlab matrix of doubles. 't' / 'tensor' : Returns fluidcell . Returns: out : Sum over index .","title":"fluidcell"},{"location":"iFluidTensor/#fluidcell","text":"Quantities like the root densities of TBAs are functions of position and rapidity. Additionally, some TBAs contain multiple root densitites, each describing a different type of quasiparticle. Thus, the numerical representation of the root density can be achieved with a rank-3 tensor. Meanwhile, quantites like the two-body scattering phase encodes the interaction between two quasiparticles of (potentially) different type and rapidity. Thus, an extra type and rapidity arguement are needed resulting in a rank-5 tensor representation. Consider one of the most central operations of GHD calculations, namely the dressing of some quantity, h . This implies solving the set of linear equations: We won't be going into specifics regarding the quantities of the equation, however, the subscripts mark the rapidity indices, while the superscripts mark the quasiparticle type indices. The calculation requires contracting over two indices - similar to a matrix multiplication, which is just the contraction over a single index, The fluidcell class wraps around a standard Matlab 5-dimensional matrix and generalizes many of the standard 2-dimensional methods (such as matrix multiplication) to 4D. Thus, the multiplication above can be computed in iFluid via h = U*h_dr or solving the equation via h_dr = U\\h . To achieve this, the fluidcell class enforces a strict convention for indices, namely Main rapidity index. Position index. Main type index. Secondary rapidity index. Secondary type index. The purpose of the fluidcell is to perform multi-index contractions using the standard Matlab notation, which is achieved by overloading the mathematical operators + - ./ * .* \\ .^ . The indices of the fluidcell can be accessed using the standard Matlab referencing for arrays. Similarly, the index labels (name of indices) can be used for referencing as well. A = B(:,:,3) % returns the 3rd type index of B B(:,:,3) = A % sets the 3rd type index of B equal to A A = B('type',3) % returns the 3rd type index of B B('type',3) = A % sets the 3rd type index of B equal to A","title":"fluidcell"},{"location":"iFluidTensor/#constructor","text":"An fluidcell object can be initialized using a MAtlab ND-array, which the fluidcell will then wrap around.","title":"Constructor"},{"location":"iFluidTensor/#obj-fluidcella","text":"Construct an fluidcell object using the ND-array input A as datastructure. Inputs: A : Standard Matlab ND-array up to 5 dimensions. Returns: obj : fluidcell object.","title":"obj = fluidcell(A)"},{"location":"iFluidTensor/#obj-fluidcellzerosd1-d2-dn","text":"or","title":"obj = fluidcell.zeros(d1, d2, ... , dN )"},{"location":"iFluidTensor/#obj-fluidcellzeros-d1-d2-dn","text":"Construct an fluidcell object of zeros with indices of specified sizes (up to N = 5 indices). Inputs: d1, d2, ... , dN : Integers indicating size of the n 'th index. Returns: obj : fluidcell object.","title":"obj = fluidcell.zeros( [d1, d2, ... , dN] )"},{"location":"iFluidTensor/#obj-fluidcellonesd1-d2-dn","text":"or","title":"obj = fluidcell.ones(d1, d2, ... , dN )"},{"location":"iFluidTensor/#obj-fluidcellones-d1-d2-dn","text":"Construct an fluidcell object of ones with indices of specified sizes (up to N = 5 indices). Inputs: d1, d2, ... , dN : Integers indicating size of the n 'th index. Returns: obj : fluidcell object.","title":"obj = fluidcell.ones( [d1, d2, ... , dN] )"},{"location":"iFluidTensor/#obj-fluidcelleye-d_rapid-d_type","text":"Construct a \"square\" fluidcell object with ones at entries with matching rapidity and type indices. Inputs: d_rapid : Integer indicating size of the main and secondary rapidity index. d_type : Integer indicating size of the main and secondary type index. Returns: obj : fluidcell object.","title":"obj = fluidcell.eye( d_rapid, d_type )"},{"location":"iFluidTensor/#accessor-methods","text":"","title":"Accessor methods"},{"location":"iFluidTensor/#s-sizeobj-idx","text":"Returns size of entire tensor or one of its indices. Inputs: idx : (optional) Index in question. Returns: S : Sizes of all or specified index.","title":"S = size(obj, idx)"},{"location":"iFluidTensor/#out-doubleobj","text":"Returns tensor as standard Matlab matrix of doubles. Returns: out : Underlying matrix.","title":"out = double(obj)"},{"location":"iFluidTensor/#index-manipulation-methods","text":"","title":"Index manipulation methods"},{"location":"iFluidTensor/#out-flattenobj","text":"Returns a 3-dimensional matrix. The first index is the main rapidity index merged with the main type index. The second index is the secondary rapidity index merged with the secondary type index. The third index is the spatial index. Returns: out : Flattened tensor.","title":"out = flatten(obj)"},{"location":"iFluidTensor/#out-unflattenobj","text":"Undoes the flatten() transformation. Returns: out : Un-flattened tensor.","title":"out = unflatten(obj)"},{"location":"iFluidTensor/#out-transposeobj-out-tobj","text":"Returns tensor with both the two rapidity and the two type indices permuted. Returns: out : Transposed tensor.","title":"out = transpose(obj) / out = t(obj)"},{"location":"iFluidTensor/#mathematical-operators","text":"The fluidcell class overloads the elementwise mathematically operations + - ./ .* .^ along with abs() log() exp() Below are the overloaded methods, which have a different function than their Matlab counterpart.","title":"Mathematical operators"},{"location":"iFluidTensor/#c-mtimesa-b-c-ab","text":"Performs the two-index contraction Inputs: A : Matrix or tensor with dimensions ( Ra, Xa, Ta, N, L ) , with position index length, Xa , equal to 1 or M . B : Matrix or tensor with dimensions ( N, Xb, L, Rb, Tb ) , with position index length, Xb , equal to 1 or M . Returns: C : Matrix or tensor with dimensions ( Ra, max(Xa, Xb), Ta, Rb, Tb ) .","title":"C = mtimes(A, B) / C = A*B"},{"location":"iFluidTensor/#x-mldividea-b-x-ab","text":"Solves the system of linear equations Inputs: A : Matrix or tensor with dimensions ( N, Xa, L, Ra, Ta ) , with position index length, Xa , equal to 1 or M . B : Matrix or tensor with dimensions ( N, Xb, L, Rb, Tb ) , with position index length, Xb , equal to 1 or M . Returns: x : Matrix or tensor with dimensions ( Ra, max(Xa, Xb), Ta, Rb, Tb ) .","title":"x = mldivide(A, B) / x = A\\B"},{"location":"iFluidTensor/#b-inva","text":"Returns the solution to the equations Inputs: A : Tensor with both rapidity indices and both type indices of equal length. Returns: B : \"Inverse\" of A .","title":"B = inv(A)"},{"location":"iFluidTensor/#out-sumobj-idx-t_str","text":"Returns the tensor summed over the given index. Inputs: idx : Integer, or vector of integers, indicating the index in quation. t_str : (optional) String indicating output type: 'd' / 'double' : Returns standard Matlab matrix of doubles. 't' / 'tensor' : Returns fluidcell . Returns: out : Sum over index .","title":"out = sum(obj, idx, t_str)"},{"location":"model/","text":"Implementing a new model This example demonstrates how to implement a model in iFluid. Before implementing a model, one should understand the basics of the thermodynamic Bethe ansatz (TBA). The introductory iFluid paper contains a short review of the necessary theory. The model The model in question is not a real integrable model - it merely serves as a demonstration. The implementation of a model essentially consists of programming its thermodynamic Bethe ansatz. For that we need the single particle energy and momentum along with the two-body scattering phase: where j denotes the quasiparticle type, while A and B are the couplings of our model. Furhtermore, let's assume the quasiparticles of our model to follow fermionic statistics. Defining the class Create a new model by extending the iFluidCore class. classdef myModel iFluidCore The constructor of our model class simply calls the constructor of the iFluidCore class. function obj = myModel(x_grid, rapid_grid, rapid_w, couplings, Options) obj = obj@iFluidCore(x_grid, rapid_grid, rapid_w, couplings, Ntypes, Options); end Implementing the TBA Next we must implement the abstract properties and methods of the iFluidCore class. First we specify the quasipaticle statistics: properties (Access = protected) quasiSpecies = 'fermion'; end Next we must implement the energy, momentum and two-body scattering phase of our model along with their derivatives w.r.t. the rapidity: function ebare = getBareEnergy(obj, t, x, rapid, type) % We take B to be the second coupling ebare = rapid.^2 + j.*obj.couplings{1,2}(t,x); end function pbare = getBareMomentum(obj, t, x, rapid, type) pbare = 4*rapid; end function de = getEnergyRapidDeriv(obj, t, x, rapid, type) de = 2*rapid; end function dp = getMomentumRapidDeriv(obj, t, x, rapid, type) % We should return something of same length as rapid dp = repmat(4, length(rapid), 1); end function dT = getScatteringRapidDeriv(obj, t, x, rapid1, rapid2, type1, type2) % We take A to be the first coupling dT = (type1-type2).*obj.couplings{1,1}(t,x)./( (rapid1-rapid2).^2 + obj.couplings{1,1}(t,x).^2 ); % Scattering kernel should be returned as an fluidcell dT = fluidcell(dT); end Note that all operations in general should be elementwise, as x , lambda and type are most often vectors. Finally, we have to implement functions providing the derivatives w.r.t. the couplings A and B : function de = getEnergyCouplingDeriv(obj, coupIdx, t, x, rapid, type) if coupIdx == 1 % Derivative w.r.t. A de = 0; else % Derivative w.r.t. B de = repmat( type, length(rapid), 1); end end function dp = getMomentumCouplingDeriv(obj, coupIdx, t, x, rapid, type) if coupIdx == 1 % Derivative w.r.t. A dp = 0; else % Derivative w.r.t. B dp = 0; end end function dT = getScatteringCouplingDeriv(obj, coupIdx, t, x, rapid1, rapid2, type1, type2) if coupIdx == 1 % Derivative w.r.t. A dT = -(type1-type2).*(rapid1-rapid2)./( (rapid1-rapid2).^2 + obj.couplings{1,1}(t,x).^2 ); else % Derivative w.r.t. B dT = 0; end dT = fluidcell(dT); end And that's it! We have now implemented our own model, which is fully integrated in the iFluid framework.","title":"Implementing a new model"},{"location":"model/#implementing-a-new-model","text":"This example demonstrates how to implement a model in iFluid. Before implementing a model, one should understand the basics of the thermodynamic Bethe ansatz (TBA). The introductory iFluid paper contains a short review of the necessary theory.","title":"Implementing a new model"},{"location":"model/#the-model","text":"The model in question is not a real integrable model - it merely serves as a demonstration. The implementation of a model essentially consists of programming its thermodynamic Bethe ansatz. For that we need the single particle energy and momentum along with the two-body scattering phase: where j denotes the quasiparticle type, while A and B are the couplings of our model. Furhtermore, let's assume the quasiparticles of our model to follow fermionic statistics.","title":"The model"},{"location":"model/#defining-the-class","text":"Create a new model by extending the iFluidCore class. classdef myModel iFluidCore The constructor of our model class simply calls the constructor of the iFluidCore class. function obj = myModel(x_grid, rapid_grid, rapid_w, couplings, Options) obj = obj@iFluidCore(x_grid, rapid_grid, rapid_w, couplings, Ntypes, Options); end","title":"Defining the class"},{"location":"model/#implementing-the-tba","text":"Next we must implement the abstract properties and methods of the iFluidCore class. First we specify the quasipaticle statistics: properties (Access = protected) quasiSpecies = 'fermion'; end Next we must implement the energy, momentum and two-body scattering phase of our model along with their derivatives w.r.t. the rapidity: function ebare = getBareEnergy(obj, t, x, rapid, type) % We take B to be the second coupling ebare = rapid.^2 + j.*obj.couplings{1,2}(t,x); end function pbare = getBareMomentum(obj, t, x, rapid, type) pbare = 4*rapid; end function de = getEnergyRapidDeriv(obj, t, x, rapid, type) de = 2*rapid; end function dp = getMomentumRapidDeriv(obj, t, x, rapid, type) % We should return something of same length as rapid dp = repmat(4, length(rapid), 1); end function dT = getScatteringRapidDeriv(obj, t, x, rapid1, rapid2, type1, type2) % We take A to be the first coupling dT = (type1-type2).*obj.couplings{1,1}(t,x)./( (rapid1-rapid2).^2 + obj.couplings{1,1}(t,x).^2 ); % Scattering kernel should be returned as an fluidcell dT = fluidcell(dT); end Note that all operations in general should be elementwise, as x , lambda and type are most often vectors. Finally, we have to implement functions providing the derivatives w.r.t. the couplings A and B : function de = getEnergyCouplingDeriv(obj, coupIdx, t, x, rapid, type) if coupIdx == 1 % Derivative w.r.t. A de = 0; else % Derivative w.r.t. B de = repmat( type, length(rapid), 1); end end function dp = getMomentumCouplingDeriv(obj, coupIdx, t, x, rapid, type) if coupIdx == 1 % Derivative w.r.t. A dp = 0; else % Derivative w.r.t. B dp = 0; end end function dT = getScatteringCouplingDeriv(obj, coupIdx, t, x, rapid1, rapid2, type1, type2) if coupIdx == 1 % Derivative w.r.t. A dT = -(type1-type2).*(rapid1-rapid2)./( (rapid1-rapid2).^2 + obj.couplings{1,1}(t,x).^2 ); else % Derivative w.r.t. B dT = 0; end dT = fluidcell(dT); end And that's it! We have now implemented our own model, which is fully integrated in the iFluid framework.","title":"Implementing the TBA"},{"location":"solver/","text":"Implementing a new solver This example demonstrates how to implement a first-order stepper to solve the GHD equation: The new solver must extend the iFluidSolver class and implement the abstract methods step() and initialize() . The equation above admidts the implicit solution where the trajectories are given by and The equations for the trajectories are also implicit, as the effective velcity and acceleration depends on the state of the system at the given time. The solver presented in this example provides a first-order approximation to the trajectories. The algorithm The iFluid solvers must provide a solution for a single time-step To first order we approximate the trajectories as and Defining the class Create a new solver by extending the iFluidSolver class. classdef FirstOrderSolver iFluidSolver Quantities like the effective and velocity and acceleration are calculated in the iFluidCore class. Therefore, we must pass an object of said class to our solver upon instantiation and store it for future use. This is taken care of by passing the object to the superclass constructor: function obj = FirstOrderSolver(coreObj, Options) obj = obj@iFluidSolver(coreObj, Options); end Implementing the stepper Next, we implement the abstract method step() , which propagates our system a single time step. function [theta_next, u_next, w_next] = performFirstOrderStep(obj, theta_prev, u_prev, w_prev, t, dt) [v_eff, a_eff] = obj.coreObj.calcEffectiveVelocities(theta_prev, t, obj.x_grid, obj.rapid_grid, obj.type_grid); x_tilde = obj.x_grid - dt*v_eff; r_tilde = obj.rapid_grid - dt*a_eff; theta_next = obj.interpPhaseSpace(theta_prev, r_tilde, x_tilde, obj.extrapFlag); u_next = obj.interpPhaseSpace(u_prev, r_tilde, x_tilde, true ); % always extrapolate u w_next = obj.interpPhaseSpace(w_prev, r_tilde, x_tilde, true ); % always extrapolate u end The method interpPhaseSpace() takes care of interpolating a quantity defined on the pre-specified grids to the points of the trajectories. Implementing the initializer Finally, we have the implement the abstract method initialize() , which prepares any quantities needed for the first time step to proceed. The first order algorithm specified here does not require such quantities. Therefore, we don't have to do anything special in the initialize() method. function [theta, u, w] = initialize(obj, theta_init, u_init, w_init, t_array) theta = theta_init; u = u_init; w = w_init; end Application Once the steps above are completed, the newly implemented solver can be instantiated and used for solving the GHD equation: Solver1 = FirstOrderSolver( someModel ); theta_t = Solver1.propagateTheta( theta_init, t_array ); Related: How to implement you own model","title":"Implementing a new algorithm"},{"location":"solver/#implementing-a-new-solver","text":"This example demonstrates how to implement a first-order stepper to solve the GHD equation: The new solver must extend the iFluidSolver class and implement the abstract methods step() and initialize() . The equation above admidts the implicit solution where the trajectories are given by and The equations for the trajectories are also implicit, as the effective velcity and acceleration depends on the state of the system at the given time. The solver presented in this example provides a first-order approximation to the trajectories.","title":"Implementing a new solver"},{"location":"solver/#the-algorithm","text":"The iFluid solvers must provide a solution for a single time-step To first order we approximate the trajectories as and","title":"The algorithm"},{"location":"solver/#defining-the-class","text":"Create a new solver by extending the iFluidSolver class. classdef FirstOrderSolver iFluidSolver Quantities like the effective and velocity and acceleration are calculated in the iFluidCore class. Therefore, we must pass an object of said class to our solver upon instantiation and store it for future use. This is taken care of by passing the object to the superclass constructor: function obj = FirstOrderSolver(coreObj, Options) obj = obj@iFluidSolver(coreObj, Options); end","title":"Defining the class"},{"location":"solver/#implementing-the-stepper","text":"Next, we implement the abstract method step() , which propagates our system a single time step. function [theta_next, u_next, w_next] = performFirstOrderStep(obj, theta_prev, u_prev, w_prev, t, dt) [v_eff, a_eff] = obj.coreObj.calcEffectiveVelocities(theta_prev, t, obj.x_grid, obj.rapid_grid, obj.type_grid); x_tilde = obj.x_grid - dt*v_eff; r_tilde = obj.rapid_grid - dt*a_eff; theta_next = obj.interpPhaseSpace(theta_prev, r_tilde, x_tilde, obj.extrapFlag); u_next = obj.interpPhaseSpace(u_prev, r_tilde, x_tilde, true ); % always extrapolate u w_next = obj.interpPhaseSpace(w_prev, r_tilde, x_tilde, true ); % always extrapolate u end The method interpPhaseSpace() takes care of interpolating a quantity defined on the pre-specified grids to the points of the trajectories.","title":"Implementing the stepper"},{"location":"solver/#implementing-the-initializer","text":"Finally, we have the implement the abstract method initialize() , which prepares any quantities needed for the first time step to proceed. The first order algorithm specified here does not require such quantities. Therefore, we don't have to do anything special in the initialize() method. function [theta, u, w] = initialize(obj, theta_init, u_init, w_init, t_array) theta = theta_init; u = u_init; w = w_init; end","title":"Implementing the initializer"},{"location":"solver/#application","text":"Once the steps above are completed, the newly implemented solver can be instantiated and used for solving the GHD equation: Solver1 = FirstOrderSolver( someModel ); theta_t = Solver1.propagateTheta( theta_init, t_array ); Related: How to implement you own model","title":"Application"}]}